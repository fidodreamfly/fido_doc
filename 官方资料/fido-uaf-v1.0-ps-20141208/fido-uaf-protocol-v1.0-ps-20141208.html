<!DOCTYPE html>
<html lang="en" dir="ltr" typeof="bibo:Document w3p:REC" about="" property="dcterms:language" content="en">
<head>
    <title>FIDO UAF Protocol Specification v1.0</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    
    
    


  <style>/*****************************************************************
 * ReSpec 3 CSS
 * Robin Berjon - http://berjon.com/
 *****************************************************************/

/* --- INLINES --- */
em.rfc2119 { 
    text-transform:     lowercase;
    font-variant:       small-caps;
    font-style:         normal;
    color:              #900;
}

h1 acronym, h2 acronym, h3 acronym, h4 acronym, h5 acronym, h6 acronym, a acronym,
h1 abbr, h2 abbr, h3 abbr, h4 abbr, h5 abbr, h6 abbr, a abbr {
    border: none;
}

dfn {
    font-weight:    bold;
}

a.internalDFN {
    color:  inherit;
    border-bottom:  1px solid #99c;
    text-decoration:    none;
}

a.externalDFN {
    color:  inherit;
    border-bottom:  1px dotted #ccc;
    text-decoration:    none;
}

a.bibref {
    text-decoration:    none;
}

cite .bibref {
    font-style: normal;
}

code {
    color:  #ff4500;
}

/* --- TOC --- */
.toc a, .tof a {
    text-decoration:    none;
}

a .secno, a .figno {
    color:  #000;
}

ul.tof, ol.tof {
    list-style: none outside none;
}

.caption {
    margin-top: 0.5em;
    font-style:   italic;
}

/* --- TABLE --- */
table.simple {
    border-spacing: 0;
    border-collapse:    collapse;
    border-bottom:  3px solid #003a7c;
}

.simple th {
    background: #003a7c;
    color:  #fff;
    padding:    3px 5px;
    text-align: left;
}

.simple th[scope="row"] {
    background: inherit;
    color:  inherit;
    border-top: 1px solid #ddd;
}

.simple td {
    padding:    3px 10px;
    border-top: 1px solid #ddd;
}

.simple tr:nth-child(even) {
    background: #f0f6ff;
}

/* --- DL --- */
.section dd > p:first-child {
    margin-top: 0;
}

.section dd > p:last-child {
    margin-bottom: 0;
}

.section dd {
    margin-bottom:  1em;
}

.section dl.attrs dd, .section dl.eldef dd {
    margin-bottom:  0;
}

@media print {
    .removeOnSave {
        display: none;
    }
}
</style><style>/* --- EXAMPLES --- */
div.example-title {
    min-width: 7.5em;
    color: #b9ab2d;
}
div.example-title span {
    text-transform: uppercase;   
}
aside.example, div.example, div.illegal-example {
    padding: 0.5em;
    margin: 1em 0;
    position: relative;
    clear: both;
}
div.illegal-example { color: red }
div.illegal-example p { color: black }
aside.example, div.example {
    padding: .5em;
    border-left-width: .5em;
    border-left-style: solid;
    border-color: #e0cb52;
    //background: #fcfaee;    
    background: rgba(252,250,238,0.3);    
}

aside.example div.example {
    border-left-width: .1em;
    border-color: #999;
    background: #fff;
}
aside.example div.example div.example-title {
    color: #999;
}
</style><style>/* --- ISSUES/NOTES --- */
div.issue-title, div.note-title {
    padding-right:  1em;
    min-width: 7.5em;
    color: #b9ab2d;
}
div.issue-title { color: #e05252; }
div.note-title { color: #2b2; }
div.issue-title span, div.note-title span {
    text-transform: uppercase;
}
div.note, div.issue {
    margin-top: 1em;
    margin-bottom: 1em;
}
.note > p:first-child, .issue > p:first-child { margin-top: 0 }
.issue, .note {
    padding: .5em;
    border-left-width: .5em;
    border-left-style: solid;
}
div.issue, div.note {
    padding: 1em 1.2em 0.5em;
    margin: 1em 0;
    position: relative;
    clear: both;
}
span.note, span.issue { padding: .1em .5em .15em; }

.issue {
    border-color: #e05252;
    background: #fbe9e9;
}
.note {
    border-color: #52e052;
    background: #e9fbe9;
}


</style><style>/* --- WEB IDL --- */
pre.idl {
    border-top: 1px solid #364e50;
    border-bottom: 1px solid #364e50;
    padding:    1em;
    line-height:    120%;
}

pre.idl::before {
    content:    "WebIDL";
    display:    block;
    width:      150px;
    background: #364e50;
    color:  #fff;
    font-family:    initial;
    padding:    3px;
    font-weight:    bold;
    margin: -1em 0 1em -1em;
}

.idlType {
    color:  #ff4500;
    font-weight:    bold;
    text-decoration:    none;
}

/*.idlModule*/
/*.idlModuleID*/
/*.idlInterface*/
.idlInterfaceID, .idlDictionaryID, .idlCallbackID, .idlEnumID {
    font-weight:    bold;
    color:  #003a7c;
}
a.idlEnumItem {
    color:  #000;
    border-bottom:  1px dotted #ccc;
    text-decoration: none;
}

.idlSuperclass {
    font-style: italic;
    color:  #003a7c;
}

/*.idlAttribute*/
.idlAttrType, .idlFieldType, .idlMemberType {
    color:  #003a7c;
}
.idlAttrName, .idlFieldName, .idlMemberName {
    color:  #ff4500;
}
.idlAttrName a, .idlFieldName a, .idlMemberName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlMethod*/
.idlMethType, .idlCallbackType {
    color:  #003a7c;
}
.idlMethName {
    color:  #ff4500;
}
.idlMethName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlCtor*/
.idlCtorName {
    color:  #ff4500;
}
.idlCtorName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlParam*/
.idlParamType {
    color:  #003a7c;
}
.idlParamName, .idlDefaultValue {
    font-style: italic;
}

.extAttr {
    color:  #666;
}

/*.idlSectionComment*/
.idlSectionComment {
    color: gray;
}

/*.idlConst*/
.idlConstType {
    color:  #003a7c;
}
.idlConstName {
    color:  #ff4500;
}
.idlConstName a {
    color:  #ff4500;
    border-bottom:  1px dotted #ff4500;
    text-decoration: none;
}

/*.idlException*/
.idlExceptionID {
    font-weight:    bold;
    color:  #c00;
}

.idlTypedefID, .idlTypedefType {
    color:  #003a7c;
}

.idlRaises, .idlRaises a.idlType, .idlRaises a.idlType code, .excName a, .excName a code {
    color:  #c00;
    font-weight:    normal;
}

.excName a {
    font-family:    monospace;
}

.idlRaises a.idlType, .excName a.idlType {
    border-bottom:  1px dotted #c00;
}

.excGetSetTrue, .excGetSetFalse, .prmNullTrue, .prmNullFalse, .prmOptTrue, .prmOptFalse {
    width:  45px;
    text-align: center;
}
.excGetSetTrue, .prmNullTrue, .prmOptTrue { color:  #0c0; }
.excGetSetFalse, .prmNullFalse, .prmOptFalse { color:  #c00; }

.idlImplements a {
    font-weight:    bold;
}

dl.attributes, dl.methods, dl.constants, dl.constructors, dl.fields, dl.dictionary-members {
    margin-left:    2em;
}

.attributes dt, .methods dt, .constants dt, .constructors dt, .fields dt, .dictionary-members dt {
    font-weight:    normal;
}

.attributes dt code, .methods dt code, .constants dt code, .constructors dt code, .fields dt code, .dictionary-members dt code {
    font-weight:    bold;
    color:  #000;
    font-family:    monospace;
}

.attributes dt code, .fields dt code, .dictionary-members dt code {
    background:  #ffffd2;
}

.attributes dt .idlAttrType code, .fields dt .idlFieldType code, .dictionary-members dt .idlMemberType code {
    color:  #003a7c;
    background:  transparent;
    font-family:    inherit;
    font-weight:    normal;
    font-style: italic;
}

.methods dt code {
    background:  #d9e6f8;
}

.constants dt code {
    background:  #ddffd2;
}

.constructors dt code {
    background:  #cfc;
}

.attributes dd, .methods dd, .constants dd, .constructors dd, .fields dd, .dictionary-members dd {
    margin-bottom:  1em;
}

table.parameters, table.exceptions {
    border-spacing: 0;
    border-collapse:    collapse;
    margin: 0.5em 0;
    width:  100%;
}
table.parameters { border-bottom:  1px solid #364e50; }
table.exceptions { border-bottom:  1px solid #deb890; }

.parameters th, .exceptions th {
    color:  #fff;
    padding:    3px 5px;
    text-align: left;
    font-family:    initial;
    font-weight:    normal;
    text-shadow:    #666 1px 1px 0;
}
.parameters th { background: #364e50; }
.exceptions th { background: #deb890; }

.parameters td, .exceptions td {
    padding:    3px 10px;
    border-top: 1px solid #ddd;
    vertical-align: top;
}

.parameters tr:first-child td, .exceptions tr:first-child td {
    border-top: none;
}

.parameters td.prmName, .exceptions td.excName, .exceptions td.excCodeName {
    width:  100px;
}

.parameters td.prmType {
    width:  120px;
}

table.exceptions table {
    border-spacing: 0;
    border-collapse:    collapse;
    width:  100%;
}
</style><link rel="stylesheet" href="resources/FIDO-PS.css"><!--[if lt IE 9]><script src='https://www.w3.org/2008/site/js/html5shiv.js'></script><![endif]--></head>

 <body style="" class="h-entry" role="document" id="respecDocument"><div class="head" role="contentinfo" id="respecHeader">
  <p>
    
      <a href="https://www.fidoalliance.org/"><img width="250" id="toplogo" src="resources/logo.png" alt="FIDO Alliance"></a>
    
  </p>
  <h1 class="title p-name" id="title" property="dcterms:title">FIDO UAF Protocol Specification v1.0</h1>
  
  <h2 property="dcterms:issued" datatype="xsd:dateTime" content="2014-12-08T08:00:00.000Z" id="fido-alliance-proposed-standard-08-december-2014"><abbr title="FIDO Alliance">FIDO Alliance</abbr> Proposed Standard <time class="dt-published" datetime="2014-12-08">08 December 2014</time></h2>
  <dl>
    
      <dt>This version:</dt>
      <dd><a class="u-url" href="https://fidoalliance.org/specs/fido-uaf-v1.0-ps-20141208/fido-uaf-protocol-v1.0-ps-20141208.html">https://fidoalliance.org/specs/fido-uaf-v1.0-ps-20141208/fido-uaf-protocol-v1.0-ps-20141208.html</a></dd>
      <!--<dt>Latest published version:</dt>
      <dd><a href='https://fidoalliance.org/specs/fido-uaf-protocol/'>https://fidoalliance.org/specs/fido-uaf-protocol/</a></dd>
    
    -->
    
    
    
    
    
      <dt>Previous version:</dt>
      <dd><a rel="dcterms:replaces" href="https://fidoalliance.org/specs/fido-uaf-protocol-v1.0-rd-20141008.pdf">https://fidoalliance.org/specs/fido-uaf-protocol-v1.0-rd-20141008.pdf</a></dd>
    
    
    <dt>Editors:</dt>
    <dd class="p-author h-card vcard" rel="bibo:editor" inlist=""><span typeof="foaf:Person"><span property="foaf:name" class="p-name fn">Dr. Rolf Lindemann</span>, <a rel="foaf:workplaceHomepage" class="p-org org h-org h-card" href="https://www.noknok.com/">Nok Nok Labs, Inc.</a></span>
</dd>
<dd class="p-author h-card vcard" rel="bibo:editor" inlist=""><span typeof="foaf:Person"><span property="foaf:name" class="p-name fn">Davit Baghdasaryan</span>, <a rel="foaf:workplaceHomepage" class="p-org org h-org h-card" href="https://www.noknok.com/">Nok Nok Labs, Inc.</a></span>
</dd>
<dd class="p-author h-card vcard" rel="bibo:editor" inlist=""><span typeof="foaf:Person"><span property="foaf:name" class="p-name fn">Eric Tiffany</span>, <a rel="foaf:workplaceHomepage" class="p-org org h-org h-card" href="https://fidoalliance.org/"><abbr title="FIDO Alliance">FIDO Alliance</abbr></a></span>
</dd>

    
      <dt>Contributors:</dt>
      <dd class="p-author h-card vcard" rel="dcterms:contributor"><span typeof="foaf:Person"><span property="foaf:name" class="p-name fn">Dirk Balfanz</span>, <a rel="foaf:workplaceHomepage" class="p-org org h-org h-card" href="https://www.google.com/">Google, Inc.</a></span>
</dd>
<dd class="p-author h-card vcard" rel="dcterms:contributor"><span typeof="foaf:Person"><a class="u-url url p-name fn" rel="foaf:homepage" property="foaf:name" content="Brad Hill" href="mailto:hillbrad@gmail.com">Brad Hill</a>, <a rel="foaf:workplaceHomepage" class="p-org org h-org h-card" href="https://www.paypal.com/">PayPal, Inc.</a></span>
</dd>
<dd class="p-author h-card vcard" rel="dcterms:contributor"><span typeof="foaf:Person"><a class="u-url url p-name fn" rel="foaf:homepage" property="foaf:name" content="Jeff Hodges" href="mailto:Jeff.Hodges@KingsMountain.com">Jeff Hodges</a>, <a rel="foaf:workplaceHomepage" class="p-org org h-org h-card" href="https://www.paypal.com/">PayPal, Inc.</a></span>
</dd>

    
    
  </dl>
  
  
  
    <p>
      The English version of this specification is the only normative version. Non-normative
      <a href="https://www.fidoalliance.org/specifications/translation/">translations</a> may also be available.
    </p>
  
  
    
      <p class="copyright">
        Copyright ©
        2013-2014
        
        <a href="https://www.fidoalliance.org/"><abbr title="FIDO Alliance">FIDO Alliance</abbr></a>
        All Rights Reserved.
      </p>
    
  
  <hr>
</div>
    <!-- only modify this if a custom Status of this Document is needed -->
    

    <section id="abstract" class="introductory" property="dcterms:abstract" datatype="" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter"><h2 aria-level="1" role="heading" id="h2_abstract">Abstract</h2>
	<p>The goal of the Universal Authentication Framework is to provide
	  a unified and extensible authentication mechanism that supplants
	  passwords while avoiding the shortcomings of current alternative
	  authentication approaches.</p>
	<p>This approach is designed to allow
	  the relying party to choose the best available authentication
	  mechanism for a particular end user or interaction, while
	  preserving the option to leverage
	  emerging device security capabilities in the future without
	  requiring additional integration effort.</p>
        <p>This document describes the FIDO architecture in detail, it
	  defines the flow and content of all UAF protocol messages and
	  presents the rationale behind the design choices.</p>
    </section><section id="sotd" class="introductory" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter"><h2 aria-level="1" role="heading" id="h2_sotd">Status of This Document</h2>
  
    
      
        <p>
          <em>This section describes the status of this document at the time of its publication.
          Other documents may supersede this document. A list of current <abbr title="FIDO Alliance">FIDO Alliance</abbr> publications and the
          latest revision of this technical report can be found in the <a href="https://www.fidoalliance.org/specifications/"><abbr title="FIDO Alliance">FIDO Alliance</abbr> specifications index</a> at
          https://www.fidoalliance.org/specifications/.</em>
        </p>
        
        <p>
          This document was published by the <a href="https://fidoalliance.org/"><abbr title="FIDO Alliance">FIDO Alliance</abbr></a> as a Proposed Standard.
          
          
            If you wish to make comments regarding this document, please 
            <a href="https://fidoalliance.org/contact">Contact Us</a>.
          
          
          
          
            All comments are welcome.
          
        </p>
        
	
	
	
        
          <p>
	    Implementation of certain elements of this Specification may require licenses under third party intellectual 
	    property rights, including without limitation, patent rights. The <abbr title="FIDO Alliance">FIDO Alliance</abbr>, Inc. and its Members
            and any other contributors to the Specification are not, and shall not be held, responsible in any manner
            for identifying or failing to identify any or all such third party intellectual property rights.
	  </p>
	  <p>
	    THIS FIDO ALLIANCE SPECIFICATION IS PROVIDED “AS IS” AND WITHOUT ANY 
            WARRANTY OF ANY KIND, INCLUDING, WITHOUT LIMITATION, ANY EXPRESS OR IMPLIED
	    WARRANTY OF NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A
	    PARTICULAR PURPOSE.
          </p>
        
        
          <p>
            This document has been reviewed by FIDO Aliance Members
            and is endorsed as a Proposed Standard.
            It is a stable document and may be used as reference material or cited from another
            document. <abbr title="FIDO Alliance">FIDO Alliance</abbr>'s role in making the Recommendation is to draw attention to the
            specification and to promote its widespread deployment.
          </p>
        
        
        
      
    
  
</section><section id="toc"><h2 class="introductory" aria-level="1" role="heading" id="h2_toc">Table of Contents</h2><ul class="toc" role="directory" id="respecContents"><li class="tocline"><a href="#notation" class="tocxref"><span class="secno">1. </span>Notation</a><ul class="toc"><li class="tocline"><a href="#key-words" class="tocxref"><span class="secno">1.1 </span>Key Words</a></li></ul></li><li class="tocline"><a href="#overview" class="tocxref"><span class="secno">2. </span>Overview</a><ul class="toc"><li class="tocline"><a href="#scope" class="tocxref"><span class="secno">2.1 </span>Scope</a></li><li class="tocline"><a href="#architecture" class="tocxref"><span class="secno">2.2 </span>Architecture</a></li><li class="tocline"><a href="#protocol-conversation" class="tocxref"><span class="secno">2.3 </span>Protocol Conversation</a><ul class="toc"><li class="tocline"><a href="#registration" class="tocxref"><span class="secno">2.3.1 </span>Registration</a></li><li class="tocline"><a href="#authentication" class="tocxref"><span class="secno">2.3.2 </span>Authentication</a></li><li class="tocline"><a href="#transaction-confirmation" class="tocxref"><span class="secno">2.3.3 </span>Transaction Confirmation</a></li><li class="tocline"><a href="#deregistration" class="tocxref"><span class="secno">2.3.4 </span>Deregistration</a></li></ul></li></ul></li><li class="tocline"><a href="#protocol-details" class="tocxref"><span class="secno">3. </span>Protocol Details</a><ul class="toc"><li class="tocline"><a href="#shared-structures-and-types" class="tocxref"><span class="secno">3.1 </span>Shared Structures and Types</a><ul class="toc"><li class="tocline"><a href="#version-interface" class="tocxref"><span class="secno">3.1.1 </span>Version Interface</a><ul class="toc"><li class="tocline"><a href="#attributes" class="tocxref"><span class="secno">3.1.1.1 </span>Attributes</a></li></ul></li><li class="tocline"><a href="#operation-enumeration" class="tocxref"><span class="secno">3.1.2 </span>Operation enumeration</a></li><li class="tocline"><a href="#operationheader-dictionary" class="tocxref"><span class="secno">3.1.3 </span>OperationHeader dictionary</a><ul class="toc"><li class="tocline"><a href="#dictionary-operationheader-members" class="tocxref"><span class="secno">3.1.3.1 </span>Dictionary <span class="formerLink"><code>OperationHeader</code></span> Members</a></li></ul></li><li class="tocline"><a href="#authenticator-attestation-id-aaid-typedef" class="tocxref"><span class="secno">3.1.4 </span>Authenticator Attestation ID (AAID) typedef</a></li><li class="tocline"><a href="#keyid-typedef" class="tocxref"><span class="secno">3.1.5 </span>KeyID typedef</a></li><li class="tocline"><a href="#serverchallenge-typedef" class="tocxref"><span class="secno">3.1.6 </span>ServerChallenge typedef</a></li><li class="tocline"><a href="#finalchallengeparams-dictionary" class="tocxref"><span class="secno">3.1.7 </span>FinalChallengeParams dictionary</a><ul class="toc"><li class="tocline"><a href="#dictionary-finalchallengeparams-members" class="tocxref"><span class="secno">3.1.7.1 </span>Dictionary <span class="formerLink"><code>FinalChallengeParams</code></span> Members</a></li></ul></li><li class="tocline"><a href="#tls-channelbinding-dictionary" class="tocxref"><span class="secno">3.1.8 </span>TLS ChannelBinding dictionary</a><ul class="toc"><li class="tocline"><a href="#dictionary-channelbinding-members" class="tocxref"><span class="secno">3.1.8.1 </span>Dictionary <span class="formerLink"><code>ChannelBinding</code></span> Members</a></li></ul></li><li class="tocline"><a href="#jwkkey-dictionary" class="tocxref"><span class="secno">3.1.9 </span>JwkKey dictionary</a><ul class="toc"><li class="tocline"><a href="#dictionary-jwkkey-members" class="tocxref"><span class="secno">3.1.9.1 </span>Dictionary <span class="formerLink"><code>JwkKey</code></span> Members</a></li></ul></li><li class="tocline"><a href="#extension-dictionary" class="tocxref"><span class="secno">3.1.10 </span>Extension dictionary</a><ul class="toc"><li class="tocline"><a href="#dictionary-extension-members" class="tocxref"><span class="secno">3.1.10.1 </span>Dictionary <span class="formerLink"><code>Extension</code></span> Members</a></li></ul></li><li class="tocline"><a href="#matchcriteria-dictionary" class="tocxref"><span class="secno">3.1.11 </span>MatchCriteria dictionary</a><ul class="toc"><li class="tocline"><a href="#dictionary-matchcriteria-members" class="tocxref"><span class="secno">3.1.11.1 </span>Dictionary <span class="formerLink"><code>MatchCriteria</code></span> Members</a></li></ul></li><li class="tocline"><a href="#policy-dictionary" class="tocxref"><span class="secno">3.1.12 </span>Policy dictionary</a><ul class="toc"><li class="tocline"><a href="#dictionary-policy-members" class="tocxref"><span class="secno">3.1.12.1 </span>Dictionary <span class="formerLink"><code>Policy</code></span> Members</a></li></ul></li></ul></li><li class="tocline"><a href="#processing-rules-for-the-server-policy" class="tocxref"><span class="secno">3.2 </span>Processing Rules for the Server Policy</a><ul class="toc"><li class="tocline"><a href="#examples" class="tocxref"><span class="secno">3.2.1 </span>Examples</a></li></ul></li><li class="tocline"><a href="#version-negotiation" class="tocxref"><span class="secno">3.3 </span>Version Negotiation</a></li><li class="tocline"><a href="#registration-operation" class="tocxref"><span class="secno">3.4 </span>Registration Operation</a><ul class="toc"><li class="tocline"><a href="#registration-request-message" class="tocxref"><span class="secno">3.4.1 </span>Registration Request Message</a></li><li class="tocline"><a href="#registrationrequest-dictionary" class="tocxref"><span class="secno">3.4.2 </span>RegistrationRequest dictionary</a><ul class="toc"><li class="tocline"><a href="#dictionary-registrationrequest-members" class="tocxref"><span class="secno">3.4.2.1 </span>Dictionary <span class="formerLink"><code>RegistrationRequest</code></span> Members</a></li></ul></li><li class="tocline"><a href="#authenticatorregistrationassertion-dictionary" class="tocxref"><span class="secno">3.4.3 </span>AuthenticatorRegistrationAssertion dictionary</a><ul class="toc"><li class="tocline"><a href="#dictionary-authenticatorregistrationassertion-members" class="tocxref"><span class="secno">3.4.3.1 </span>Dictionary <span class="formerLink"><code>AuthenticatorRegistrationAssertion</code></span> Members</a></li></ul></li><li class="tocline"><a href="#registration-response-message" class="tocxref"><span class="secno">3.4.4 </span>Registration Response Message</a></li><li class="tocline"><a href="#registrationresponse-dictionary" class="tocxref"><span class="secno">3.4.5 </span>RegistrationResponse dictionary</a><ul class="toc"><li class="tocline"><a href="#dictionary-registrationresponse-members" class="tocxref"><span class="secno">3.4.5.1 </span>Dictionary <span class="formerLink"><code>RegistrationResponse</code></span> Members</a></li></ul></li><li class="tocline"><a href="#registration-processing-rules" class="tocxref"><span class="secno">3.4.6 </span>Registration Processing Rules</a><ul class="toc"><li class="tocline"><a href="#registration-request-generation-rules-for-fido-server" class="tocxref"><span class="secno">3.4.6.1 </span>Registration Request Generation Rules for FIDO Server</a></li><li class="tocline"><a href="#registration-request-processing-rules-for-fido-uaf-clients" class="tocxref"><span class="secno">3.4.6.2 </span>Registration Request Processing Rules for FIDO UAF Clients</a></li><li class="tocline"><a href="#registration-request-processing-rules-for-fido-authenticator" class="tocxref"><span class="secno">3.4.6.3 </span>Registration Request Processing Rules for FIDO Authenticator</a></li><li class="tocline"><a href="#registration-response-generation-rules-for-fido-uaf-client" class="tocxref"><span class="secno">3.4.6.4 </span>Registration Response Generation Rules for FIDO UAF Client</a></li><li class="tocline"><a href="#registration-response-processing-rules-for-fido-server" class="tocxref"><span class="secno">3.4.6.5 </span>Registration Response Processing Rules for FIDO Server</a></li></ul></li></ul></li><li class="tocline"><a href="#authentication-operation" class="tocxref"><span class="secno">3.5 </span>Authentication Operation</a><ul class="toc"><li class="tocline"><a href="#transaction-dictionary" class="tocxref"><span class="secno">3.5.1 </span>Transaction dictionary</a><ul class="toc"><li class="tocline"><a href="#dictionary-transaction-members" class="tocxref"><span class="secno">3.5.1.1 </span>Dictionary <span class="formerLink"><code>Transaction</code></span> Members</a></li></ul></li><li class="tocline"><a href="#authentication-request-message" class="tocxref"><span class="secno">3.5.2 </span>Authentication Request Message</a></li><li class="tocline"><a href="#authenticationrequest-dictionary" class="tocxref"><span class="secno">3.5.3 </span>AuthenticationRequest dictionary</a><ul class="toc"><li class="tocline"><a href="#dictionary-authenticationrequest-members" class="tocxref"><span class="secno">3.5.3.1 </span>Dictionary <span class="formerLink"><code>AuthenticationRequest</code></span> Members</a></li></ul></li><li class="tocline"><a href="#authenticatorsignassertion-dictionary" class="tocxref"><span class="secno">3.5.4 </span>AuthenticatorSignAssertion dictionary</a><ul class="toc"><li class="tocline"><a href="#dictionary-authenticatorsignassertion-members" class="tocxref"><span class="secno">3.5.4.1 </span>Dictionary <span class="formerLink"><code>AuthenticatorSignAssertion</code></span> Members</a></li></ul></li><li class="tocline"><a href="#authenticationresponse-dictionary" class="tocxref"><span class="secno">3.5.5 </span>AuthenticationResponse dictionary</a><ul class="toc"><li class="tocline"><a href="#dictionary-authenticationresponse-members" class="tocxref"><span class="secno">3.5.5.1 </span>Dictionary <span class="formerLink"><code>AuthenticationResponse</code></span> Members</a></li></ul></li><li class="tocline"><a href="#authentication-response-message" class="tocxref"><span class="secno">3.5.6 </span>Authentication Response Message</a></li><li class="tocline"><a href="#authentication-processing-rules" class="tocxref"><span class="secno">3.5.7 </span>Authentication Processing Rules</a><ul class="toc"><li class="tocline"><a href="#authentication-request-generation-rules-for-fido-server" class="tocxref"><span class="secno">3.5.7.1 </span>Authentication Request Generation Rules for FIDO Server</a></li><li class="tocline"><a href="#authentication-request-processing-rules-for-fido-uaf-client" class="tocxref"><span class="secno">3.5.7.2 </span>Authentication Request Processing Rules for FIDO UAF Client</a></li><li class="tocline"><a href="#authentication-request-processing-rules-for-fido-authenticator" class="tocxref"><span class="secno">3.5.7.3 </span>Authentication Request Processing Rules for FIDO Authenticator</a></li><li class="tocline"><a href="#authentication-response-generation-rules-for-fido-uaf-client" class="tocxref"><span class="secno">3.5.7.4 </span>Authentication Response Generation Rules for FIDO UAF Client</a></li><li class="tocline"><a href="#authentication-response-processing-rules-for-fido-server" class="tocxref"><span class="secno">3.5.7.5 </span>Authentication Response Processing Rules for FIDO Server</a></li></ul></li></ul></li><li class="tocline"><a href="#deregistration-operation" class="tocxref"><span class="secno">3.6 </span>Deregistration Operation</a><ul class="toc"><li class="tocline"><a href="#deregistration-request-message" class="tocxref"><span class="secno">3.6.1 </span>Deregistration Request Message</a></li><li class="tocline"><a href="#deregisterauthenticator-dictionary" class="tocxref"><span class="secno">3.6.2 </span>DeregisterAuthenticator dictionary</a><ul class="toc"><li class="tocline"><a href="#dictionary-deregisterauthenticator-members" class="tocxref"><span class="secno">3.6.2.1 </span>Dictionary <span class="formerLink"><code>DeregisterAuthenticator</code></span> Members</a></li></ul></li><li class="tocline"><a href="#deregistrationrequest-dictionary" class="tocxref"><span class="secno">3.6.3 </span>DeregistrationRequest dictionary</a><ul class="toc"><li class="tocline"><a href="#dictionary-deregistrationrequest-members" class="tocxref"><span class="secno">3.6.3.1 </span>Dictionary <span class="formerLink"><code>DeregistrationRequest</code></span> Members</a></li></ul></li><li class="tocline"><a href="#deregistration-processing-rules" class="tocxref"><span class="secno">3.6.4 </span>Deregistration Processing Rules</a><ul class="toc"><li class="tocline"><a href="#deregistration-request-generation-rules-for-fido-server" class="tocxref"><span class="secno">3.6.4.1 </span>Deregistration Request Generation Rules for FIDO Server</a></li><li class="tocline"><a href="#deregistration-request-processing-rules-for-fido-uaf-client" class="tocxref"><span class="secno">3.6.4.2 </span>Deregistration Request Processing Rules for FIDO UAF Client</a></li><li class="tocline"><a href="#deregistration-request-processing-rules-for-fido-authenticator" class="tocxref"><span class="secno">3.6.4.3 </span>Deregistration Request Processing Rules for FIDO Authenticator</a></li></ul></li></ul></li></ul></li><li class="tocline"><a href="#considerations" class="tocxref"><span class="secno">4. </span>Considerations</a><ul class="toc"><li class="tocline"><a href="#protocol-core-design-considerations" class="tocxref"><span class="secno">4.1 </span>Protocol Core Design Considerations</a><ul class="toc"><li class="tocline"><a href="#authenticator-metadata" class="tocxref"><span class="secno">4.1.1 </span>Authenticator Metadata</a></li><li class="tocline"><a href="#authenticator-attestation" class="tocxref"><span class="secno">4.1.2 </span>Authenticator Attestation</a><ul class="toc"><li class="tocline"><a href="#basic-attestation" class="tocxref"><span class="secno">4.1.2.1 </span>Basic Attestation</a><ul class="toc"><li class="tocline"><a href="#full-basic-attestation" class="tocxref"><span class="secno">4.1.2.1.1 </span>Full Basic Attestation</a></li><li class="tocline"><a href="#surrogate-basic-attestation" class="tocxref"><span class="secno">4.1.2.1.2 </span>Surrogate Basic Attestation</a></li></ul></li></ul></li><li class="tocline"><a href="#error-handling" class="tocxref"><span class="secno">4.1.3 </span>Error Handling</a></li><li class="tocline"><a href="#assertion-schemes" class="tocxref"><span class="secno">4.1.4 </span>Assertion Schemes</a></li><li class="tocline"><a href="#username-in-authenticator" class="tocxref"><span class="secno">4.1.5 </span>Username in Authenticator</a></li><li class="tocline"><a href="#tls-protected-communication" class="tocxref"><span class="secno">4.1.6 </span>TLS Protected Communication</a></li></ul></li><li class="tocline"><a href="#implementation-considerations" class="tocxref"><span class="secno">4.2 </span>Implementation Considerations</a><ul class="toc"><li class="tocline"><a href="#server-challenge-and-random-numbers" class="tocxref"><span class="secno">4.2.1 </span>Server Challenge and Random Numbers</a></li></ul></li><li class="tocline"><a href="#security-considerations" class="tocxref"><span class="secno">4.3 </span>Security Considerations</a><ul class="toc"><li class="tocline"><a href="#fido-authenticator-security" class="tocxref"><span class="secno">4.3.1 </span>FIDO Authenticator Security</a></li><li class="tocline"><a href="#cryptographic-algorithms" class="tocxref"><span class="secno">4.3.2 </span>Cryptographic Algorithms</a></li><li class="tocline"><a href="#application-isolation" class="tocxref"><span class="secno">4.3.3 </span>Application Isolation</a><ul class="toc"><li class="tocline"><a href="#isolation-using-khaccesstoken" class="tocxref"><span class="secno">4.3.3.1 </span>Isolation using KHAccessToken</a></li></ul></li><li class="tocline"><a href="#tls-binding" class="tocxref"><span class="secno">4.3.4 </span>TLS Binding</a></li><li class="tocline"><a href="#session-management" class="tocxref"><span class="secno">4.3.5 </span>Session Management</a></li><li class="tocline"><a href="#personas" class="tocxref"><span class="secno">4.3.6 </span>Personas</a></li><li class="tocline"><a href="#serverdata-and-keyhandle" class="tocxref"><span class="secno">4.3.7 </span>ServerData and KeyHandle</a></li><li class="tocline"><a href="#authenticator-information-retrieved-through-uaf-application-api-vs.-metadata" class="tocxref"><span class="secno">4.3.8 </span>Authenticator Information retrieved through UAF Application API vs.
	    Metadata</a></li><li class="tocline"><a href="#policy-verification" class="tocxref"><span class="secno">4.3.9 </span>Policy Verification</a></li><li class="tocline"><a href="#replay-attack-protection" class="tocxref"><span class="secno">4.3.10 </span>Replay Attack Protection</a></li><li class="tocline"><a href="#protection-against-cloned-authenticators" class="tocxref"><span class="secno">4.3.11 </span>Protection against Cloned Authenticators</a></li><li class="tocline"><a href="#anti-fraud-signals" class="tocxref"><span class="secno">4.3.12 </span>Anti-Fraud Signals</a></li></ul></li><li class="tocline"><a href="#interoperability-considerations" class="tocxref"><span class="secno">4.4 </span>Interoperability Considerations</a></li></ul></li><li class="tocline"><a href="#uaf-supported-assertion-schemes" class="tocxref"><span class="secno">5. </span>UAF Supported Assertion Schemes</a><ul class="toc"><li class="tocline"><a href="#assertion-scheme-uafv1tlv" class="tocxref"><span class="secno">5.1 </span>Assertion Scheme "UAFV1TLV"</a><ul class="toc"><li class="tocline"><a href="#keyregistrationdata" class="tocxref"><span class="secno">5.1.1 </span>KeyRegistrationData</a></li><li class="tocline"><a href="#signeddata" class="tocxref"><span class="secno">5.1.2 </span>SignedData</a></li></ul></li></ul></li><li class="tocline"><a href="#definitions" class="tocxref"><span class="secno">6. </span>Definitions</a></li><li class="tocline"><a href="#tof" class="tocxref"><span class="secno">7. </span>Table of Figures</a></li><li class="tocline"><a href="#references" class="tocxref"><span class="secno">A. </span>References</a><ul class="toc"><li class="tocline"><a href="#normative-references" class="tocxref"><span class="secno">A.1 </span>Normative references</a></li><li class="tocline"><a href="#informative-references" class="tocxref"><span class="secno">A.2 </span>Informative references</a></li></ul></li></ul></section>

    <section id="notation">
      <!--OddPage--><h2 aria-level="1" role="heading" id="h2_notation"><span class="secno">1. </span>Notation</h2>
      
      <p>Type names, attribute names and element names are written as <code>code</code>.
	
      </p><p>String literals are enclosed in “”, e.g. “UAF-TLV”.
	
      </p><p>In formulas we use “|” to denote byte wise concatenation
        operations.

	</p><p>The notation base64url refers to "Base 64 Encoding with URL and Filename
	  Safe Alphabet" [<cite><a class="bibref" href="#bib-RFC4648">RFC4648</a></cite>] <em>without padding</em>.  </p>

        <p>Following [<cite><a class="bibref" href="#bib-WebIDL-ED">WebIDL-ED</a></cite>], dictionary members are optional unless 
	  they are explicitly marked as <code>required</code>.</p>

        <p>WebIDL dictionary members <em class="rfc2119" title="MUST NOT">MUST NOT</em> have a value of null.</p>

        <p>Unless otherwise specified, if a WebIDL dictionary member 
	  is DOMString, it <em class="rfc2119" title="MUST NOT">MUST NOT</em> be empty.</p>

        <p>Unless otherwise specified, if a WebIDL dictionary member is a List, 
	  it <em class="rfc2119" title="MUST NOT">MUST NOT</em> be an empty list.</p>

        <p>UAF specific terminology used in this document is defined in
          [<cite><a class="bibref" href="#bib-FIDOGlossary">FIDOGlossary</a></cite>].</p>

        <p>All diagrams, examples, notes in this specification are non-normative.</p>

	<div class="note"><div class="note-title" aria-level="2" role="heading" id="h_note_1"><span>Note</span></div><p class="">
	  Note: Certain dictionary members need to be present in order to
	  comply with FIDO requirements. Such members are marked in the
	  WebIDL definitions found in this document, as
	  <code>required</code>. The keyword <code>required</code> has been
	  introduced by [<cite><a class="bibref" href="#bib-WebIDL-ED">WebIDL-ED</a></cite>], which is a work-in-progress. If you
	  are using a WebIDL parser which implements [<cite><a class="bibref" href="#bib-WebIDL">WebIDL</a></cite>], then you
	  may remove the keyword <code>required</code> from your WebIDL and
	  use other means to ensure those fields are present.  
	</p></div>
	
        <section id="key-words">
          <h3 aria-level="2" role="heading" id="h3_key-words"><span class="secno">1.1 </span>Key Words</h3>
	  
          <p>The key words “<em class="rfc2119" title="MUST">MUST</em>”, “<em class="rfc2119" title="MUST NOT">MUST NOT</em>”, “<em class="rfc2119" title="REQUIRED">REQUIRED</em>”, “<em class="rfc2119" title="SHALL">SHALL</em>”, “<em class="rfc2119" title="SHALL
            NOT">SHALL
            NOT</em>”, “<em class="rfc2119" title="SHOULD">SHOULD</em>”, “<em class="rfc2119" title="SHOULD NOT">SHOULD NOT</em>”, “<em class="rfc2119" title="RECOMMENDED">RECOMMENDED</em>”, “<em class="rfc2119" title="MAY">MAY</em>”, and
            “<em class="rfc2119" title="OPTIONAL">OPTIONAL</em>” in this document are to be interpreted as described in [<cite><a class="bibref" href="#bib-RFC2119">RFC2119</a></cite>].</p>
        </section>
    </section>

    <section class="informative" id="overview">
      <!--OddPage--><h2 aria-level="1" role="heading" id="h2_overview"><span class="secno">2. </span>Overview</h2><p><em>This section is non-normative.</em></p>
      <p>
	The goal of this Universal Authentication Framework is to
	provide a unified and extensible authentication mechanism that
	supplants passwords while avoiding the shortcomings of current
	alternative authentication approaches.</p>
      <p>The design goal of the protocol is to enable Relying Parties
	to leverage the diverse and heterogeneous set of security
	capabilities available on end users' devices via a single,
	unified protocol.</p>
      <p>This approach is designed to allow the
	FIDO Relying Parties to choose the best available authentication
	mechanism for a particular end user or interaction, while
	preserving the option for a relying party to leverage
	emerging device security capabilities in the future, without
	requiring additional integration effort.
      </p>

      <section id="scope">
	<h3 aria-level="2" role="heading" id="h3_scope"><span class="secno">2.1 </span>Scope</h3>
	<p>
	  This document describes FIDO architecture in detail and defines
	  the UAF protocol as a network protocol. It defines the flow and
	  content of all UAF messages and presents the rationale behind
	  the design choices.</p>
	<p>
	  Particular application-level bindings are outside the scope of
	  this document. This document is not intended to answer
	  questions such as:</p>
	<ul>
	  <li>
	    What does an HTTP binding look like for UAF?
	  </li>
	  <li>
	    How can a web application communicate to FIDO UAF Client?
	  </li>
	  <li>
	    How can FIDO UAF Client communicate to FIDO enabled Authenticators?
	  </li>
	</ul>
	<p>The answers to these questions can be found in other UAF
	  specifications, e.g. [<cite><a class="bibref" href="#bib-UAFAppAPIAndTransport">UAFAppAPIAndTransport</a></cite>] [<cite><a class="bibref" href="#bib-UAFASM">UAFASM</a></cite>]
	  [<cite><a class="bibref" href="#bib-UAFAuthnrCommands">UAFAuthnrCommands</a></cite>].</p>
      </section>

	<section id="architecture">
	  <h3 aria-level="2" role="heading" id="h3_architecture"><span class="secno">2.2 </span>Architecture</h3>
	    <p>The following diagram depicts the entities involved in UAF
	      protocol.</p>

	    <figure id="fig-the-uaf-architecture">
	      <img src="./img/fido-uaf-architecture.png" onerror="./img/fido-uaf-architecture.png" alt="UAF Architecture">
	      <figcaption>Fig. <span class="figno">1</span> <span class="fig-title">The UAF Architecture</span></figcaption>
            </figure>

	    <p>Of these entities, only these three directly create and/or
	      process UAF protocol messages:</p>

	    <ul>
	      <li>FIDO Server, running on the relying party's infrastructure</li>
	      <li>FIDO UAF Client, part of the user agent and running on the FIDO user
	        device</li>
	      <li>FIDO Authenticator, integrated into the FIDO user device</li>
	    </ul>

	    <p>It is assumed in this document that a FIDO Server has access to
	      the UAF Authenticator Metadata [<cite><a class="bibref" href="#bib-UAFAuthnrMetadata">UAFAuthnrMetadata</a></cite>] describing
	      all the authenticators it will interact with.</p>
	</section>

        <section id="protocol-conversation">
	  <h3 aria-level="2" role="heading" id="h3_protocol-conversation"><span class="secno">2.3 </span>Protocol Conversation</h3>
	  <p>
	    The core UAF protocol consists of four conceptual conversations
	    between a FIDO UAF Client and FIDO Server.
	  </p>
	  <ul>
	    <li>
	      <p>
		<strong>Registration:</strong> UAF allows the relying party to register a FIDO
		Authenticator with the user's account at the relying party. The
		relying party can specify a policy for supporting various FIDO
		Authenticator types. A FIDO UAF Client will only register existing
		authenticators in accordance with that policy.</p>
	    </li>
	    <li>
	      <p>
		<strong>Authentication:</strong> UAF allows the relying party to prompt the end
		user to authenticate using a previously registered FIDO
		Authenticator. This authentication can be invoked any time, at
		the relying party's discretion.</p>
	    </li>
	    <li>
	      <p>
		<strong>Transaction Confirmation:</strong> In addition to providing a general
		authentication prompt, UAF offers support for prompting the
		user to confirm a specific transaction.</p>
	      <p>This prompt includes
		the ability to communicate additional information to the client
		for display to the end user, using the client's transaction confirmation display. 
		The goal of this additional authentication operation is to enable relying parties to ensure
		that the user is confirming a specified set of the transaction
		details (instead of authenticating a session to the user agent).</p>
	    </li>
	    <li>
	      <p>
		<strong>Deregistration:</strong> The relying party can trigger the deletion of
		the account-related authentication key material.</p>
	    </li>
	  </ul>
	<p>
	  Although this document defines the FIDO Server as the initiator
	  of requests, in a real world deployment the first UAF operation
	  will always follow a user agent's (e.g. HTTP) request
	  to a relying party.</p>
	
	<p>
	  The following sections give a brief overview of the protocol
	  conversation for individual operations. More detailed
	  descriptions can be found in the sections <a href="#registration-operation">Registration
	  Operation</a>, <a href="#authentication-operation">Authentication Operation</a>, 
	  and <a href="#deregistration-operation">Deregistration Operation</a>.</p>
	
	<section id="registration">
	  
	  <h4 aria-level="3" role="heading" id="h4_registration"><span class="secno">2.3.1 </span>Registration</h4>
	  <p>
	    The following diagram shows the message flows for
	    registration.</p>
	  
	  <figure id="fig-uaf-registration-message-flow">	  
	    <img src="./img/fido-uaf-protocol-registration.png" onerror="./img/fido-uaf-protocol-registration.png" alt="UAF Registration Message Flow">
	    <figcaption>Fig. <span class="figno">2</span> <span class="fig-title">UAF Registration Message Flow</span></figcaption>
          </figure>
	  
	  <div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_2"><span>Note</span></div><p class="">The client application should use the appropriate API 
	    to inform the FIDO UAF Client of the results of the 
	    operation (see section 2.3.1 in [<cite><a class="bibref" href="#bib-UAFAppAPIAndTransport">UAFAppAPIAndTransport</a></cite>]) in order 
	    to allow the FIDO UAF Client to do some "housekeeping" tasks. 
	  </p></div>

	</section>
	<section id="authentication">
	  <h4 aria-level="3" role="heading" id="h4_authentication"><span class="secno">2.3.2 </span>Authentication</h4>
	  
	  <p>
	    The following diagram depicts the message flows for the
	    authentication operation.</p>
	  
	  <figure id="fig-authentication-message-flow">	  
	    <img src="./img/fido-uaf-protocol-authentication.png" onerror="./img/fido-uaf-protocol-authentication.png" alt="Authentication Message Flow">
	    <figcaption>Fig. <span class="figno">3</span> <span class="fig-title">Authentication Message Flow</span></figcaption>
          </figure>
	  
	  <div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_3"><span>Note</span></div><p class="">The client application should use the appropriate API 
	    to inform the FIDO UAF Client of the results of the 
	    operation (see section 2.3.1 in [<cite><a class="bibref" href="#bib-UAFAppAPIAndTransport">UAFAppAPIAndTransport</a></cite>]) in order 
	    to allow FIDO UAF Client to do some "housekeeping" tasks. 
	  </p></div>

	</section>
	
	<section id="transaction-confirmation">
	  <h4 aria-level="3" role="heading" id="h4_transaction-confirmation"><span class="secno">2.3.3 </span>Transaction Confirmation</h4>
	  
	  <p>
	    The following figure depicts the transaction confirmation
	    message flow.</p>
	    
	  <figure id="fig-transaction-confirmation-message-flow">	  
	    <img src="./img/fido-uaf-protocol-transaction-confirm.png" onerror="./img/fido-uaf-protocol-transaction-confirm.png" alt="Transaction Confirmation Message Flow">
	    <figcaption>Fig. <span class="figno">4</span> <span class="fig-title">Transaction Confirmation Message Flow</span></figcaption>
          </figure>
	  
	  <div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_4"><span>Note</span></div><p class="">The client application should use the appropriate API 
	    to inform the FIDO UAF Client of the results of the 
	    operation (see section 2.3.1 in [<cite><a class="bibref" href="#bib-UAFAppAPIAndTransport">UAFAppAPIAndTransport</a></cite>]) in order 
	    to allow the FIDO UAF Client to do some "housekeeping" tasks. 
	  </p></div>

	</section>
	
	<section id="deregistration">
	  <h4 aria-level="3" role="heading" id="h4_deregistration"><span class="secno">2.3.4 </span>Deregistration</h4>
	  
	  <p>
	    The following diagram depicts the deregistration message flow.</p>
	  
	  <figure id="fig-deregistration-message-flow">	  
	    <img src="./img/fido-uaf-protocol-deregistration.png" onerror="./img/fido-uaf-protocol-deregistration.png" alt="Deregistration Message Flow">
	    <figcaption>Fig. <span class="figno">5</span> <span class="fig-title">Deregistration Message Flow</span></figcaption>
          </figure>

	  <div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_5"><span>Note</span></div><p class="">The client application should use the appropriate API 
	    to inform the FIDO UAF Client of the results of the 
	    operation (see section 2.3.1 in [<cite><a class="bibref" href="#bib-UAFAppAPIAndTransport">UAFAppAPIAndTransport</a></cite>]) in order 
	    to allow the FIDO UAF Client to do some "housekeeping" tasks. 
	  </p></div>
	  
	</section>
      </section>
    </section>

    <section class="normativeDisclaimer" id="protocol-details">
      <!--OddPage--><h2 aria-level="1" role="heading" id="h2_protocol-details"><span class="secno">3. </span>Protocol Details</h2><p><em>This section is normative.</em></p>
      
      <p>
	This section provides a detailed description of operations
	supported by the UAF Protocol.
      </p>
      
      <p class="conformance">Support of all protocol elements is
	mandatory for conforming software, unless stated otherwise.
      </p>
      
      <p>
	All string literals in this specification are constructed from
	Unicode codepoints within the set <code>U+0000</code>..<code>U+007F</code>.
      </p>

      <p>Unless otherwise specified, protocol messages are transferred
	with a UTF-8 content encoding.</p>
      
      <div class="note"><div class="note-title" aria-level="2" role="heading" id="h_note_6"><span>Note</span></div><p class="certification">
	All data used in this protocol must be exchanged using a secure
	transport protocol (such as TLS/HTTPS) established between the FIDO UAF Client
	and the relying party in order to follow the assumptions made in [<cite><a class="bibref" href="#bib-FIDOSecRef">FIDOSecRef</a></cite>]; 
	details are specified in section <a href="#tls-protected-communication" class="sec-ref"><span class="secno">4.1.6</span> <span class="sec-title">TLS Protected Communication</span></a>.</p></div>
      
      <p>
	The notation <code>base64url(byte[8..64])</code>  reads as 8-64 bytes of data
	encoded in base64url, "Base 64 Encoding with URL and Filename
	Safe Alphabet" [<cite><a class="bibref" href="#bib-RFC4648">RFC4648</a></cite>] <i>without padding</i>.  
      </p>

      <p>
	The notation <code>string[5]</code> reads as five unicode characters, represented as a
	UTF-8 [<cite><a class="bibref" href="#bib-RFC3629">RFC3629</a></cite>] encoded string of the type indicated in the declaration, typically a
	WebIDL [<cite><a class="bibref" href="#bib-WebIDL-ED">WebIDL-ED</a></cite>] DOMString.</p>
      <p>As the UTF-8 representation has variable length, the
	<i>maximum</i> byte length of <code>string[5]</code> is <code>string[4*5]</code>.
      </p>
      
      <p>
	All strings are case-sensitive unless stated otherwise.</p>
      
      <p>
	This document uses WebIDL [<cite><a class="bibref" href="#bib-WebIDL-ED">WebIDL-ED</a></cite>]to define UAF protocol messages.
      </p>

      <p>
	Implementations <em class="rfc2119" title="MUST">MUST</em> serialize the UAF protocol messages for
	transmission using UTF-8 encoded JSON [<cite><a class="bibref" href="#bib-RFC4627">RFC4627</a></cite>].
      </p>
      
      <section id="shared-structures-and-types">

	<h3 aria-level="2" role="heading" id="h3_shared-structures-and-types"><span class="secno">3.1 </span>Shared Structures and Types</h3>
      
	<p>
	  This section defines types and structures shared by various
	  operations.
	</p>
	
	<section id="version-interface">
	  <h4 aria-level="3" role="heading" id="h4_version-interface"><span class="secno">3.1.1 </span>Version Interface</h4>
	  <p>
	    Represents a generic version with major and minor fields.</p>
	  
	  <pre class="idl"><span class="idlInterface" id="idl-def-Version">interface <span class="idlInterfaceID">Version</span> {
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">unsigned short</span> <span class="idlAttrName"><a href="#widl-Version-major">major</a></span>;</span>
<span class="idlAttribute">    readonly    attribute <span class="idlAttrType">unsigned short</span> <span class="idlAttrName"><a href="#widl-Version-minor">minor</a></span>;</span>
};</span></pre><section id="attributes"><h5 aria-level="4" role="heading" id="h5_attributes"><span class="secno">3.1.1.1 </span>Attributes</h5><dl class="attributes"><dt id="widl-Version-major"><code>major</code> of type <span class="idlAttrType">unsigned short</span>, readonly   </dt><dd>Major version, 1 for this specification.</dd><dt id="widl-Version-minor"><code>minor</code> of type <span class="idlAttrType">unsigned short</span>, readonly   </dt><dd>Minor version, 0 for this specification.</dd></dl></section>

	</section>

	<section id="operation-enumeration">

	  <h4 aria-level="3" role="heading" id="h4_operation-enumeration"><span class="secno">3.1.2 </span>Operation enumeration</h4>

	  <p>Describes the operation type of a UAF message or request for a message.</p>
	    <pre class="idl"><span class="idlEnum" id="idl-def-Operation">enum <span class="idlEnumID">Operation</span> {
    "<a href="#idl-def-Operation.xReg" class="idlEnumItem">Reg</a>",
    "<a href="#idl-def-Operation.xAuth" class="idlEnumItem">Auth</a>",
    "<a href="#idl-def-Operation.xDereg" class="idlEnumItem">Dereg</a>"
};</span></pre><table class="simple"><tbody><tr><th colspan="2">Enumeration description</th></tr><tr><td><code id="idl-def-Operation.xReg">Reg</code></td><td>Registration</td></tr><tr><td><code id="idl-def-Operation.xAuth">Auth</code></td><td>Authentication or Transaction Confirmation</td></tr><tr><td><code id="idl-def-Operation.xDereg">Dereg</code></td><td>Deregistration</td></tr></tbody></table>

	</section>
	
	<section id="operationheader-dictionary"> 
	  <h4 aria-level="3" role="heading" id="h4_operationheader-dictionary"><span class="secno">3.1.3 </span>OperationHeader dictionary</h4>
	  
	  <p>Represents a UAF message Request and Response header</p>
	    
	  <pre class="idl"><span class="idlDictionary" id="idl-def-OperationHeader">dictionary <span class="idlDictionaryID">OperationHeader</span> {
<span class="idlMember">    <span class="idlMemberType">required Version</span>   <span class="idlMemberName"><a href="#widl-OperationHeader-upv">upv</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">required Operation</span> <span class="idlMemberName"><a href="#widl-OperationHeader-op">op</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">DOMString</span>          <span class="idlMemberName"><a href="#widl-OperationHeader-appID">appID</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">DOMString</span>          <span class="idlMemberName"><a href="#widl-OperationHeader-serverData">serverData</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType"><a href="#idl-def-Extension" class="idlType"><code>Extension</code></a>[]</span>        <span class="idlMemberName"><a href="#widl-OperationHeader-exts">exts</a></span>;</span>
};</span></pre><section id="dictionary-operationheader-members"><h5 aria-level="4" role="heading" id="h5_dictionary-operationheader-members"><span class="secno">3.1.3.1 </span>Dictionary <a class="idlType" href="#idl-def-OperationHeader"><code>OperationHeader</code></a> Members</h5><dl class="dictionary-members"><dt id="widl-OperationHeader-upv"><code>upv</code> of type <span class="idlMemberType">required Version</span></dt><dd>UAF protocol version. Major version <em class="rfc2119" title="MUST">MUST</em> be <code>1</code> and minor
	      version <em class="rfc2119" title="MUST">MUST</em> be <code>0</code>.</dd><dt id="widl-OperationHeader-op"><code>op</code> of type <span class="idlMemberType">required Operation</span></dt><dd>Name of FIDO operation this message relates to.
	      <div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_7"><span>Note</span></div><p class="">"Auth" is used for both authentication and transaction
		confirmation.</p></div>
	    </dd><dt id="widl-OperationHeader-appID"><code>appID</code> of type <span class="idlMemberType">DOMString</span></dt><dd><code>string[0..512]</code>.

	      <p>The application identifier that the relying party would like to assert. </p>
	      <p>There are three ways to set the <code>AppID</code> [<cite><a class="bibref" href="#bib-FIDOAppIDAndFacets">FIDOAppIDAndFacets</a></cite>]:</p>

	      <ol>

		<li>If the element is missing or empty in the request,
		  the FIDO UAF Client <em class="rfc2119" title="MUST">MUST</em> set it to the<code>FacetID</code> of the caller.</li>

		<li>If the <code>appID</code> present in the message is identical to
		  the <code>FacetID</code> of the caller, the FIDO UAF Client 
		  <em class="rfc2119" title="MUST">MUST</em> accept it.</li>

		<li>If it is an URI with HTTPS protocol scheme, the
		  FIDO UAF Client <em class="rfc2119" title="MUST">MUST</em> use it to load the list of
		  trusted facet identifiers from the specified
		  URI. The FIDO UAF Client <em class="rfc2119" title="MUST">MUST</em> only accept the
		  request, if the facet identifier of the caller
		  matches one of the trusted facet identifiers in the
		  list returned from dereferencing this URI.</li>

	      </ol>

	      <div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_8"><span>Note</span></div><div class="">

		<p>The new key pair that the authenticator generates will be
		  associated with this application identifier. </p>
		<p><em>Security Relevance:</em> The application identifier is used
		  by the FIDO UAF Client to verify the eligibility of an application
		  to trigger the use of a specific <code>UAuth.Key</code>. See [<cite><a class="bibref" href="#bib-FIDOAppIDAndFacets">FIDOAppIDAndFacets</a></cite>]
		</p>

	      </div></div>
	    </dd><dt id="widl-OperationHeader-serverData"><code>serverData</code> of type <span class="idlMemberType">DOMString</span></dt><dd> <code>string[1..1536]</code>.
	      <p> A session identifier created by the relying party. </p>
	      <div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_9"><span>Note</span></div><div class="">
		The relying party can opaquely store things like expiration times for the registration
		session, protocol version used and other useful information
		in <code>serverData</code>. This data is opaque to FIDO UAF Clients. FIDO Servers may
		reject a response that is lacking this data or is containing unauthorized
		modifications to it.
		<p>Servers that depend on the integrity of <code>serverData</code> should apply 
		  appropriate security measures, as described in
		  <a href="#registration-request-generation-rules-for-fido-server">Registration 
		    Request Generation Rules for FIDO Server</a> and section
		<a href="#serverdata-and-keyhandle">ServerData and KeyHandle</a>.</p>
	      </div></div>
	    </dd><dt id="widl-OperationHeader-exts"><code>exts</code> of type array of <span class="idlMemberType"><a href="#idl-def-Extension" class="idlType"><code>Extension</code></a></span></dt><dd>List of UAF Message Extensions.</dd></dl></section>
	  
	</section>

	<section id="authenticator-attestation-id-aaid-typedef">
	  <h4 aria-level="3" role="heading" id="h4_authenticator-attestation-id-aaid-typedef"><span class="secno">3.1.4 </span>Authenticator Attestation ID (AAID) typedef</h4>
	  
	  <pre class="idl"><span class="idlTypedef" id="idl-def-AAID">typedef <span class="idlTypedefType">DOMString</span> <span class="idlTypedefID">AAID</span>;</span></pre><div class="idlTypedefDesc">
            <code>string[9]</code>
	    <p>
	      Each authenticator <em class="rfc2119" title="MUST">MUST</em> have an <code>AAID</code> to identify UAF
	      enabled authenticator models globally. The <code>AAID</code> <em class="rfc2119" title="MUST">MUST</em> uniquely identify 
	      a specific authenticator model within the range of all UAF-enabled 
	      authenticator models made by all authenticator vendors, 
	      where authenticators of a specific model must share identical security 
	      characteristics within the model (see 
	      <a href="#security-considerations">Security Considerations</a>).
	    </p>	      
	    <p>
	      The <code>AAID</code> is a string with format "V#M", where</p>
      
	    <p>
	      "#" is a separator</p>
      
	    <p>
	      "V" indicates the authenticator Vendor Code. This code
	      consists of 4 hexadecimal digits.</p>
	    
	    <p>
	      "M" indicates the authenticator Model Code. This code consists
	      of 4 hexadecimal digits.</p>
      
	    <p>
	      The Augmented BNF [<cite><a class="bibref" href="#bib-ABNF">ABNF</a></cite>] for the <code>AAID</code> is:</p>
      
	    <p class="code">AAID = 4(HEXDIG) "#" 4(HEXDIG)</p>

	    <div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_10"><span>Note</span></div><p class="">
	      <em>HEXDIG</em> is case insensitive, i.e. "03EF" and "03ef" are
	      identical.</p></div>
      
	    <p>
	      The <abbr title="FIDO Alliance">FIDO Alliance</abbr> is responsible for assigning authenticator
	      vendor Codes. </p>
      
	    <p>
	      Authenticator vendors are responsible for assigning authenticator model codes
	      to their authenticators. Authenticator vendors <em class="rfc2119" title="MUST">MUST</em> assign
	      unique <code>AAIDs</code> to authenticators with different security
	      characteristics.</p>
	    <p>AAIDs are unique and each of them must relate to a distinct
              authentication metadata file ([<cite><a class="bibref" href="#bib-UAFAuthnrMetadata">UAFAuthnrMetadata</a></cite>])</p>
      
	    <div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_11"><span>Note</span></div><p class="">
	      Adding new firmware/software
	      features, or changing the underlying hardware protection
	      mechanisms will typically change the security characteristics
	      of an authenticator and hence would require a new <code>AAID</code> to be used. 
	      Refer to ([<cite><a class="bibref" href="#bib-UAFAuthnrMetadata">UAFAuthnrMetadata</a></cite>]) for more details.</p></div>
	  </div>

	</section> 
       
	<section id="keyid-typedef">
	  <h4 aria-level="3" role="heading" id="h4_keyid-typedef"><span class="secno">3.1.5 </span>KeyID typedef</h4>
	  
	  <pre class="idl"><span class="idlTypedef" id="idl-def-KeyID">typedef <span class="idlTypedefType">DOMString</span> <span class="idlTypedefID">KeyID</span>;</span></pre><div class="idlTypedefDesc"> 
	    <code>base64url(byte[32...2048])</code>
	    
	    <p>
	      <code>KeyID</code> is a unique identifier (within the scope of an <code>AAID</code>) used
	      to refer to a specific <code>UAuth.Key</code>. It is generated by the
	      authenticator and registered with a FIDO Server.</p>
	      
	    <p>
	      The (<code>AAID</code>, <code>KeyID</code> ) tuple <em class="rfc2119" title="MUST">MUST</em> uniquely identify an
	      authenticator's registration for a relying party. Whenever a
	      FIDO Server wants to provide specific information to a
	      particular authenticator it <em class="rfc2119" title="MUST">MUST</em> use the (<code>AAID</code>, <code>KeyID</code>) tuple.</p>
	      
	    <p>
	      <code>KeyID</code> <em class="rfc2119" title="MUST">MUST</em> be base64url encoded within the UAF message (see
	      above).</p>
      
	    <p> 
              During step-up authentication and deregistration operations, the FIDO Server <em class="rfc2119" title="SHOULD">SHOULD</em> 
	      provide the <code>KeyID</code> back to the authenticator for the latter to locate the appropriate 
	      user authentication key, and perform the necessary operation with it. </p>

	    <p>
	      Roaming authenticators which don't have internal storage
	      for, and cannot rely on any ASM to store, generated key
	      handles <em class="rfc2119" title="SHOULD">SHOULD</em> provide the key handle as part of the <code>AuthenticatorRegistrationAssertion.assertion.KeyID</code>
              during the registration operation (see also
	      section <a href="#serverdata-and-keyhandle">ServerData and KeyHandle</a>) 
	      and get the key handle back from the FIDO Server during the 
	      step-up authentication (in the 
	      <a href="#matchcriteria-dictionary"><code>MatchCriteria</code></a> dictionary which
	      is part of the <a href="#policy-dictionary">policy</a>) or deregistration operations 
	      (see [<cite><a class="bibref" href="#bib-UAFAuthnrCommands">UAFAuthnrCommands</a></cite>] for more details).</p>

	    <div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_12"><span>Note</span></div><p class="">
	      The exact structure and content of a <code>KeyID</code> is
	      specific to the authenticator implementation.</p></div>

	  </div>
	</section>

	<section id="serverchallenge-typedef">
	  <h4 aria-level="3" role="heading" id="h4_serverchallenge-typedef"><span class="secno">3.1.6 </span>ServerChallenge typedef</h4>
	  
	  <pre class="idl"><span class="idlTypedef" id="idl-def-ServerChallenge">typedef <span class="idlTypedefType">DOMString</span> <span class="idlTypedefID">ServerChallenge</span>;</span></pre><div class="idlTypedefDesc">
	    <code>base64url(byte[8...64])</code>	       
	    <p>
	      <code>ServerChallenge</code> is a server-provided random challenge. <em>Security
	      Relevance:</em> The challenge is used by the FIDO Server to verify
	      whether an incoming response is new, or has already been
	      processed. See section <a href="#replay-attack-protection">Replay Attack Protection</a> for more
	      details. </p>
	    
	    <p>
	      The <code>ServerChallenge</code> <em class="rfc2119" title="SHOULD">SHOULD</em> be mixed into the entropy pool of the
	      authenticator. <em>Security Relevance:</em> The FIDO Server <em class="rfc2119" title="SHOULD">SHOULD</em>
	      provide a challenge containing strong cryptographic randomness
	      whenever possible. See section <a href="#server-challenge-and-random-numbers">Server Challenge
	      and Random Numbers</a>.
	    </p>
	    
	    <div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_13"><span>Note</span></div><p class="">
	      The minimum challenge length of 8 bytes follows the requirement
	      in [<cite><a class="bibref" href="#bib-SP800-63">SP800-63</a></cite>] and is equivalent to the 20 decimal digits as
	      required in [<cite><a class="bibref" href="#bib-RFC6287">RFC6287</a></cite>].</p></div>	    
	    <div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_14"><span>Note</span></div><p class="">
	      The maximum length has been defined such that SHA-512 output can
	      be used without truncation.</p></div>
	    <div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_15"><span>Note</span></div><p class="">
	      The mixing of multiple sources of randomness is
	      recommended to improve the quality of the random numbers
	      generated by the authenticator, as described in [<cite><a class="bibref" href="#bib-RFC4086">RFC4086</a></cite>].</p></div>
	  </div>
	</section>

	<section id="finalchallengeparams-dictionary"> 
	  <h4 aria-level="3" role="heading" id="h4_finalchallengeparams-dictionary"><span class="secno">3.1.7 </span>FinalChallengeParams dictionary</h4>
	  
	  <pre class="idl"><span class="idlDictionary" id="idl-def-FinalChallengeParams">dictionary <span class="idlDictionaryID">FinalChallengeParams</span> {
<span class="idlMember">    <span class="idlMemberType">required DOMString</span>       <span class="idlMemberName"><a href="#widl-FinalChallengeParams-appID">appID</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">required ServerChallenge</span> <span class="idlMemberName"><a href="#widl-FinalChallengeParams-challenge">challenge</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">required DOMString</span>       <span class="idlMemberName"><a href="#widl-FinalChallengeParams-facetID">facetID</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">required ChannelBinding</span>  <span class="idlMemberName"><a href="#widl-FinalChallengeParams-channelBinding">channelBinding</a></span>;</span>
};</span></pre><section id="dictionary-finalchallengeparams-members"><h5 aria-level="4" role="heading" id="h5_dictionary-finalchallengeparams-members"><span class="secno">3.1.7.1 </span>Dictionary <a class="idlType" href="#idl-def-FinalChallengeParams"><code>FinalChallengeParams</code></a> Members</h5><dl class="dictionary-members"><dt id="widl-FinalChallengeParams-appID"><code>appID</code> of type <span class="idlMemberType">required DOMString</span></dt><dd><code>string[1..512]</code>
 	      <p>
		The value <em class="rfc2119" title="MUST">MUST</em> be taken from the <code>appID</code> field 
		of the <a title="OperationHeader" href="#idl-def-OperationHeader" class="idlType"><code>OperationHeader</code></a></p>
	    </dd><dt id="widl-FinalChallengeParams-challenge"><code>challenge</code> of type <span class="idlMemberType">required ServerChallenge</span></dt><dd>
   	      <p>
              The value <em class="rfc2119" title="MUST">MUST</em> be taken from the challenge field of the request
	      (e.g. <a href="#registrationrequest-dictionary">RegistrationRequest.challenge</a>,
		<a href="#authenticationrequest-dictionary">AuthenticationRequest.challenge</a>).</p>
	    </dd><dt id="widl-FinalChallengeParams-facetID"><code>facetID</code> of type <span class="idlMemberType">required DOMString</span></dt><dd><code>string[1..512]</code>
	      <p>
		The value is determined by the FIDO UAF Client and it depends on the
		calling application. See [<cite><a class="bibref" href="#bib-FIDOAppIDAndFacets">FIDOAppIDAndFacets</a></cite>] for more details.
		<em>Security Relevance:</em> The <code>facetID</code> is determined 
		by the FIDO UAF Client and
		verified against the list of trusted facets retrieved by dereferencing the <code>appID</code> of
		the calling application.</p>
	    </dd><dt id="widl-FinalChallengeParams-channelBinding"><code>channelBinding</code> of type <span class="idlMemberType">required ChannelBinding</span></dt><dd>
 	      <p>
		Contains the TLS information to be sent by the FIDO
		Client to the FIDO Server, binding the TLS channel to
		the FIDO operation. </p>
	    </dd></dl></section>
	  
	</section>
	<section id="tls-channelbinding-dictionary">           
	  <h4 aria-level="3" role="heading" id="h4_tls-channelbinding-dictionary"><span class="secno">3.1.8 </span>TLS ChannelBinding dictionary</h4>
	  <p>ChannelBinding contains channel binding information [<cite><a class="bibref" href="#bib-RFC5056">RFC5056</a></cite>].</p>
	  <div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_16"><span>Note</span></div><div class="">
	    <p><em>Security
		Relevance:</em>The channel binding may be verified by the FIDO Server in order
	      to detect and prevent MITM attacks.</p>
	    <p>At this time, the following channel binding methods are supported:</p>
	    <ul>
	      <li>TLS ChannelID (<code>cid_pubkey</code>) [<cite><a class="bibref" href="#bib-ChannelID">ChannelID</a></cite>]</li>
	      <li>serverEndPoint [<cite><a class="bibref" href="#bib-RFC5929">RFC5929</a></cite>]</li>
	      <li>tlsServerCertificate [<cite><a class="bibref" href="#bib-RFC5929">RFC5929</a></cite>]</li>
	      <li>tlsUnique [<cite><a class="bibref" href="#bib-RFC5929">RFC5929</a></cite>]</li>
	    </ul>
	  </div></div>

	  <p>Further requirements:
	    </p><ol>
	      <li>If data related to any of the channel binding
		methods, described here, is available to the FIDO UAF
		Client (i.e. included in this dictionary), it <em class="rfc2119" title="MUST">MUST</em> be
		used according to the relevant specification .</li>
	      <li>All channel binding methods described here <em class="rfc2119" title="MUST">MUST</em> be supported by the FIDO Server. The FIDO Server <em class="rfc2119" title="MAY">MAY</em> 
		reject operations if the channel binding cannot be verified successfully.
	      </li>
	    </ol>           
	  <p></p>
	  <div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_17"><span>Note</span></div><div class="certification">
	    <ul>
	      <li>If channel binding data is accessible to the web
		browser or client application, it must be relayed to
		the FIDO UAF Client in order to follow the assumptions
		made in [<cite><a class="bibref" href="#bib-FIDOSecRef">FIDOSecRef</a></cite>].</li>
	      <li>If channel binding data is accessible to the web server, 
		it must be relayed to the FIDO Server in order to follow the 
		assumptions made in [<cite><a class="bibref" href="#bib-FIDOSecRef">FIDOSecRef</a></cite>].  The FIDO Server 
		relies on the web server to provide
		accurate channel binding information.</li>
	    </ul>
	  </div></div>
	  <pre class="idl"><span class="idlDictionary" id="idl-def-ChannelBinding">dictionary <span class="idlDictionaryID">ChannelBinding</span> {
<span class="idlMember">    <span class="idlMemberType">DOMString</span> <span class="idlMemberName"><a href="#widl-ChannelBinding-serverEndPoint">serverEndPoint</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">DOMString</span> <span class="idlMemberName"><a href="#widl-ChannelBinding-tlsServerCertificate">tlsServerCertificate</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">DOMString</span> <span class="idlMemberName"><a href="#widl-ChannelBinding-tlsUnique">tlsUnique</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">DOMString</span> <span class="idlMemberName"><a href="#widl-ChannelBinding-cid_pubkey">cid_pubkey</a></span>;</span>
};</span></pre><section id="dictionary-channelbinding-members"><h5 aria-level="4" role="heading" id="h5_dictionary-channelbinding-members"><span class="secno">3.1.8.1 </span>Dictionary <a class="idlType" href="#idl-def-ChannelBinding"><code>ChannelBinding</code></a> Members</h5><dl class="dictionary-members"><dt id="widl-ChannelBinding-serverEndPoint"><code>serverEndPoint</code> of type <span class="idlMemberType">DOMString</span></dt><dd>
	      <p>The field <code>serverEndPoint</code> <em class="rfc2119" title="MUST">MUST</em> be set
		to the base64url-encoded hash of the TLS server
		certificate if this is available. The hash function <em class="rfc2119" title="MUST">MUST</em> be
		selected as follows:</p>
              <ol> 		
      		<li>if the certificate's <code>signatureAlgorithm</code> uses a single hash
		  function and that hash function is either MD5 [<cite><a class="bibref" href="#bib-RFC1321">RFC1321</a></cite>] or
		  SHA-1 [<cite><a class="bibref" href="#bib-RFC6234">RFC6234</a></cite>], then use SHA-256 [<cite><a class="bibref" href="#bib-FIPS180-4">FIPS180-4</a></cite>];</li>
		
       		<li>if the certificate's  <code>signatureAlgorithm</code> uses
		  a single hash function and that hash function is
		  neither MD5 nor SHA-1, then use the hash function
		  associated with the certificate's<code>signatureAlgorithm</code>;</li>
		
      		<li>if the certificate's <code>signatureAlgorithm</code> uses
		  no hash functions, or uses multiple hash functions,
		  then this channel binding type's channel bindings
		  are undefined at this time (updates to this channel
		  binding type may occur to address this issue if it
		  ever arises)</li>
              </ol>
      	      <p>This field <em class="rfc2119" title="MUST">MUST</em> be absent if the TLS server certificate is not available to the
		processing entity (e.g., the FIDO UAF Client) or the hash function
		cannot be determined as described.
	      </p>
	    </dd><dt id="widl-ChannelBinding-tlsServerCertificate"><code>tlsServerCertificate</code> of type <span class="idlMemberType">DOMString</span></dt><dd>
	      <p>This field <em class="rfc2119" title="MUST">MUST</em> be absent if the TLS server
		certificate is not available to the FIDO UAF Client.</p>
	      
      	      <p>This field <em class="rfc2119" title="MUST">MUST</em> be set to the base64url-encoded,
		DER-encoded TLS server certificate, if this data is
		available to the FIDO UAF Client.</p>
	    </dd><dt id="widl-ChannelBinding-tlsUnique"><code>tlsUnique</code> of type <span class="idlMemberType">DOMString</span></dt><dd>
              <em class="rfc2119" title="MUST">MUST</em> be set to the base64url-encoded TLS channel
	      <code>Finished</code> structure. It <em class="rfc2119" title="MUST">MUST</em>, however, be absent, if this
	      data is not available to the FIDO UAF Client
	      [<cite><a class="bibref" href="#bib-RFC5929">RFC5929</a></cite>].</dd><dt id="widl-ChannelBinding-cid_pubkey"><code>cid_pubkey</code> of type <span class="idlMemberType">DOMString</span></dt><dd>
	      <p><em class="rfc2119" title="MUST">MUST</em> be absent if the client TLS stack doesn't provide TLS ChannelID
		[<cite><a class="bibref" href="#bib-ChannelID">ChannelID</a></cite>] information to the processing entity (e.g., the web
		browser or client application).</p>
	      
      	      <p><em class="rfc2119" title="MUST">MUST</em> be set to "unused" if TLS ChannelID information is supported by
		the client-side TLS stack but has not been signaled by the TLS
		(web) server.</p>
	      
              <p>Otherwise, it <em class="rfc2119" title="MUST">MUST</em> be set to the base64url-encoded serialized
		[<cite><a class="bibref" href="#bib-RFC4627">RFC4627</a></cite>] <a title="JwkKey" href="#idl-def-JwkKey" class="idlType"><code>JwkKey</code></a> structure using UTF-8 encoding.</p>	      
	    </dd></dl></section>
	  
	</section>
	<section id="jwkkey-dictionary">
	  <h4 aria-level="3" role="heading" id="h4_jwkkey-dictionary"><span class="secno">3.1.9 </span>JwkKey dictionary</h4>
	  
	  <p><code>JwkKey</code> is a dictionary representing a JSON Web Key encoding of
	    an elliptic curve public key [<cite><a class="bibref" href="#bib-JWK">JWK</a></cite>].</p>
	  <p>This public key is the ChannelID public
	    key minted by the client TLS stack for the particular relying party.
	    [<cite><a class="bibref" href="#bib-ChannelID">ChannelID</a></cite>] stipulates using only a particular elliptic curve, and the particular
	    coordinate type.</p>
	  
	  <pre class="idl"><span class="idlDictionary" id="idl-def-JwkKey">dictionary <span class="idlDictionaryID">JwkKey</span> {
<span class="idlMember">    <span class="idlMemberType">required DOMString</span> <span class="idlMemberName"><a href="#widl-JwkKey-kty">kty</a></span> = <span class="idlMemberValue">"EC"</span>;</span>
<span class="idlMember">    <span class="idlMemberType">required DOMString</span> <span class="idlMemberName"><a href="#widl-JwkKey-crv">crv</a></span> = <span class="idlMemberValue">"P-256"</span>;</span>
<span class="idlMember">    <span class="idlMemberType">required DOMString</span> <span class="idlMemberName"><a href="#widl-JwkKey-x">x</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">required DOMString</span> <span class="idlMemberName"><a href="#widl-JwkKey-y">y</a></span>;</span>
};</span></pre><section id="dictionary-jwkkey-members"><h5 aria-level="4" role="heading" id="h5_dictionary-jwkkey-members"><span class="secno">3.1.9.1 </span>Dictionary <a class="idlType" href="#idl-def-JwkKey"><code>JwkKey</code></a> Members</h5><dl class="dictionary-members"><dt id="widl-JwkKey-kty"><code>kty</code> of type <span class="idlMemberType">required DOMString</span>, defaulting to <code>"EC"</code></dt><dd>
	      Denotes the key type used for Channel ID. At this
	      time only elliptic curve is supported by [<cite><a class="bibref" href="#bib-ChannelID">ChannelID</a></cite>], so it
	      <em class="rfc2119" title="MUST">MUST</em> be set to "EC" [<cite><a class="bibref" href="#bib-JWA">JWA</a></cite>].
	    </dd><dt id="widl-JwkKey-crv"><code>crv</code> of type <span class="idlMemberType">required DOMString</span>, defaulting to <code>"P-256"</code></dt><dd>
	      Denotes the elliptic curve on which this public
	      key is defined. At this time only the NIST curve <code>secp256r1</code> is supported by
	      [<cite><a class="bibref" href="#bib-ChannelID">ChannelID</a></cite>], so the <code>crv</code> parameter <em class="rfc2119" title="MUST">MUST</em> be set to "P-256".
	    </dd><dt id="widl-JwkKey-x"><code>x</code> of type <span class="idlMemberType">required DOMString</span></dt><dd>
              Contains the base64url-encoding of the x coordinate
	      of the public key (big-endian, 32-byte value).
	    </dd><dt id="widl-JwkKey-y"><code>y</code> of type <span class="idlMemberType">required DOMString</span></dt><dd>
              Contains the base64url-encoding of the y coordinate
	      of the public key (big-endian, 32-byte value).
	    </dd></dl></section>
	  
	  
	</section>
	<section id="extension-dictionary"> 
	  <h4 aria-level="3" role="heading" id="h4_extension-dictionary"><span class="secno">3.1.10 </span>Extension dictionary</h4>
	  
	  <p>FIDO extensions can appear in several places, including
	    the UAF protocol messages, authenticator commands, or in the
	    assertion signed by the authenticator.</p>

	  <p>Each extension has an identifier, and the namespace for
	    extension identifiers is FIDO UAF global (i.e. doesn't
	    depend on the message where the extension is present).
	  </p>

	  <p>
	    Extensions can be defined in a way such that a processing
	    entity which doesn't understand the meaning of a specific
	    extension <em class="rfc2119" title="MUST">MUST</em> abort processing, or they can be specified
	    in a way that unknown extension can (safely) be ignored.
	  </p>
	  <p>
	    Extension processing rules are defined in each section
	    where extensions are allowed.
	  </p>
	  
 	  <p>Generic extensions used in various operations.</p>
	  
	  <pre class="idl"><span class="idlDictionary" id="idl-def-Extension">dictionary <span class="idlDictionaryID">Extension</span> {
<span class="idlMember">    <span class="idlMemberType">required DOMString</span> <span class="idlMemberName"><a href="#widl-Extension-id">id</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">required DOMString</span> <span class="idlMemberName"><a href="#widl-Extension-data">data</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">required boolean</span>   <span class="idlMemberName"><a href="#widl-Extension-fail_if_unknown">fail_if_unknown</a></span>;</span>
};</span></pre><section id="dictionary-extension-members"><h5 aria-level="4" role="heading" id="h5_dictionary-extension-members"><span class="secno">3.1.10.1 </span>Dictionary <a class="idlType" href="#idl-def-Extension"><code>Extension</code></a> Members</h5><dl class="dictionary-members"><dt id="widl-Extension-id"><code>id</code> of type <span class="idlMemberType">required DOMString</span></dt><dd>   <code>string[1..32]</code>.
	      <p>Identifies the extension.</p>
	    </dd><dt id="widl-Extension-data"><code>data</code> of type <span class="idlMemberType">required DOMString</span></dt><dd>Contains arbitrary data with a semantics agreed
	      between server and client. The data is base64url-encoded.
	      <p>This field <em class="rfc2119" title="MAY">MAY</em> be empty.</p>
	    </dd><dt id="widl-Extension-fail_if_unknown"><code>fail_if_unknown</code> of type <span class="idlMemberType">required boolean</span></dt><dd> Indicates whether unknown extensions
	      must be ignored (<code>false</code>) or must lead to an
	      error (<code>true</code>).
	      <ul>
		<li>A value of <code>false</code> indicates that unknown extensions <em class="rfc2119" title="MUST">MUST</em> be ignored</li>
		<li>A value of <code>true</code> indicates that unknown extensions <em class="rfc2119" title="MUST">MUST</em> result in an error.</li>
	      </ul>
	    </dd></dl></section>
	  
	  <div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_18"><span>Note</span></div><div class="">
	    <p>The FIDO UAF Client might (a) process an extension or (b) pass the 
	      extension through to the ASM.  Unknown extensions must be passed through.
	    </p>
	    <p>The ASM might (a) process an extension or (b) pass the 
	      extension through to the FIDO authenticator.  Unknown extensions must be passed through.
	    </p>
	    <p>The FIDO authenticator must handle the extension or ignore it 
	      (only if it doesn't know how to handle it <em>and</em> 
	      <code>fail_if_unknown</code> is not set).  If the FIDO authenticator doesn't understand the
	      meaning of the extension and <code>fail_if_unknown</code> is set, it must generate an error
	      (see definition of <code>fail_if_unknown</code> above).
	    </p>
	    <p>When passing through an extension to the next entity, the <code>fail_if_unknown</code> flag
	      must be preserved (see [<cite><a class="bibref" href="#bib-UAFASM">UAFASM</a></cite>] [<cite><a class="bibref" href="#bib-UAFAuthnrCommands">UAFAuthnrCommands</a></cite>]).
	    </p>
	    <p>FIDO protocol messages are not signed.  If the security 
	      depends on an extension being known or processed, then such extension 
	      should be accompanied  by a related (and signed) extension in the authenticator 
	      assertion (e.g. <code>TAG_UAFV1_REG_ASSERTION</code>, 
	      <code>TAG_UAFV1_AUTH_ASSERTION</code>). If the security has been increased (e.g. 
	      the FIDO authenticator according to the description in the metadata statement accepts
	      multiple fingers but in this specific case indicates that the finger used at registration
	      was also used for authentication) there is no need to mark the extension as 
	      <code>fail_if_unknown</code> (i.e. tag 0x3E12 should be used [<cite><a class="bibref" href="#bib-UAFAuthnrCommands">UAFAuthnrCommands</a></cite>]).
	      If the security has been degraded (e.g. the FIDO authenticator according to the 
	      description in the metadata statement accepts only the finger used at registration for 
	      authentication but in this specific case indicates that a different finger was used 
	      for authentication) the extension must be marked as <code>fail_if_unknown</code> 
	      (i.e. tag 0x3E11 must be used [<cite><a class="bibref" href="#bib-UAFAuthnrCommands">UAFAuthnrCommands</a></cite>]).
	    </p>
	  </div></div>
	</section>

	<section id="matchcriteria-dictionary">
	  <h4 aria-level="3" role="heading" id="h4_matchcriteria-dictionary"><span class="secno">3.1.11 </span>MatchCriteria dictionary</h4>
	  <p>
	    Represents the matching criteria to
	    be used in the server policy.
	  </p>
	  <p>The <code>MatchCriteria</code> object is considered to match an authenticator, if 
	    <i>all</i> fields in the object are considered to match (as indicated
	    in the particular fields).</p>
	    
	    <pre class="idl"><span class="idlDictionary" id="idl-def-MatchCriteria">dictionary <span class="idlDictionaryID">MatchCriteria</span> {
<span class="idlMember">    <span class="idlMemberType"><a href="#idl-def-AAID" class="idlType"><code>AAID</code></a>[]</span>           <span class="idlMemberName"><a href="#widl-MatchCriteria-aaid">aaid</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">DOMString[]</span>      <span class="idlMemberName"><a href="#widl-MatchCriteria-vendorID">vendorID</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType"><a href="#idl-def-KeyID" class="idlType"><code>KeyID</code></a>[]</span>          <span class="idlMemberName"><a href="#widl-MatchCriteria-keyIDs">keyIDs</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">unsigned long</span>    <span class="idlMemberName"><a href="#widl-MatchCriteria-userVerification">userVerification</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">unsigned short</span>   <span class="idlMemberName"><a href="#widl-MatchCriteria-keyProtection">keyProtection</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">unsigned short</span>   <span class="idlMemberName"><a href="#widl-MatchCriteria-matcherProtection">matcherProtection</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">unsigned long</span>    <span class="idlMemberName"><a href="#widl-MatchCriteria-attachmentHint">attachmentHint</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">unsigned short</span>   <span class="idlMemberName"><a href="#widl-MatchCriteria-tcDisplay">tcDisplay</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">unsigned short[]</span> <span class="idlMemberName"><a href="#widl-MatchCriteria-authenticationAlgorithms">authenticationAlgorithms</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">DOMString[]</span>      <span class="idlMemberName"><a href="#widl-MatchCriteria-assertionSchemes">assertionSchemes</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">unsigned short[]</span> <span class="idlMemberName"><a href="#widl-MatchCriteria-attestationTypes">attestationTypes</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">unsigned short</span>   <span class="idlMemberName"><a href="#widl-MatchCriteria-authenticatorVersion">authenticatorVersion</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType"><a href="#idl-def-Extension" class="idlType"><code>Extension</code></a>[]</span>      <span class="idlMemberName"><a href="#widl-MatchCriteria-exts">exts</a></span>;</span>
};</span></pre><section id="dictionary-matchcriteria-members"><h5 aria-level="4" role="heading" id="h5_dictionary-matchcriteria-members"><span class="secno">3.1.11.1 </span>Dictionary <a class="idlType" href="#idl-def-MatchCriteria"><code>MatchCriteria</code></a> Members</h5><dl class="dictionary-members"><dt id="widl-MatchCriteria-aaid"><code>aaid</code> of type array of <span class="idlMemberType"><a href="#idl-def-AAID" class="idlType"><code>AAID</code></a></span></dt><dd>List of AAIDs, causing matching to be restricted to certain AAIDs.
		<p>The match succeeds if at least one AAID entry in this array 
		  matches <code>AuthenticatorInfo.aaid</code> [<cite><a class="bibref" href="#bib-UAFASM">UAFASM</a></cite>].
		</p>

		<div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_19"><span>Note</span></div><p class="">This field corresponds to <code>MetadataStatement.aaid</code> [<cite><a class="bibref" href="#bib-UAFAuthnrMetadata">UAFAuthnrMetadata</a></cite>].
		</p></div>

	      </dd><dt id="widl-MatchCriteria-vendorID"><code>vendorID</code> of type array of <span class="idlMemberType">DOMString</span></dt><dd>The vendorID causing matching to be restricted to
		authenticator models of the given vendor. The first 4 characters of 
		the AAID are the vendorID
		(see <a title="AAID" href="#idl-def-AAID" class="idlType"><code>AAID</code></a>)). 
		<p>The match succeeds if at least one entry 
		  in this array matches the first 4 
		  characters of the <code>AuthenticatorInfo.aaid</code> [<cite><a class="bibref" href="#bib-UAFASM">UAFASM</a></cite>].
		</p>
		<div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_20"><span>Note</span></div><p class="">This field corresponds to the first 4
		  characters of<code>MetadataStatement.aaid</code> [<cite><a class="bibref" href="#bib-UAFAuthnrMetadata">UAFAuthnrMetadata</a></cite>].
		</p></div> 
	      </dd><dt id="widl-MatchCriteria-keyIDs"><code>keyIDs</code> of type array of <span class="idlMemberType"><a href="#idl-def-KeyID" class="idlType"><code>KeyID</code></a></span></dt><dd>A list of authenticator KeyIDs causing matching to be
		restricted to a given set of <code>KeyID</code> instances. (see
		[<cite><a class="bibref" href="#bib-UAFRegistry">UAFRegistry</a></cite>]).
		<p>This match succeeds if at least one entry in this array matches.
		</p>
		<div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_21"><span>Note</span></div><p class="">This field corresponds to <code>AppRegistration.keyIDs</code> [<cite><a class="bibref" href="#bib-UAFASM">UAFASM</a></cite>].</p></div>
	      </dd><dt id="widl-MatchCriteria-userVerification"><code>userVerification</code> of type <span class="idlMemberType">unsigned long</span></dt><dd>A set of 32 bit flags which may be set if
		matching should be restricted by the user verification method (see
		[<cite><a class="bibref" href="#bib-UAFRegistry">UAFRegistry</a></cite>]).
		<div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_22"><span>Note</span></div><div class="">
		  The match with <code>AuthenticatorInfo.userVerification</code>
		  ([<cite><a class="bibref" href="#bib-UAFASM">UAFASM</a></cite>]) succeeds, if the following condition
		  holds (written in Java):
		  
		  <p>
		    </p><pre class="code">if (
        // They are equal
        (AuthenticatorInfo.userVerification == MatchCriteria.userVerification) ||

        // USER_VERIFY_ALL is not set in both of them and they have at least one common bit set
        (
            ((AuthenticatorInfo.userVerification &amp; USER_VERIFY_ALL) == 0) &amp;&amp;
            ((MatchCriteria.userVerification &amp; USER_VERIFY_ALL) == 0) &amp;&amp;
            ((AuthenticatorInfo.userVerification &amp; MatchCriteria.userVerification) != 0)
        )
   )
		    </pre>
		  <p></p>
		</div></div>
		<div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_23"><span>Note</span></div><div class="">
		  This field value can be derived from <code>MetadataStatement.userVerificationDetails</code>
		  as follows:
		  <ol>
		    <li>if <code>MetadataStatement.userVerificationDetails</code> contains 
		      multiple entries, then:
		      <ol>
			<li>if one or more entries <code>MetadataStatement.userVerificationDetails[i]</code> 
			  contain multiple entries, then: stop, direct derivation is not possible. Must generate
			  <code>MatchCriteria</code> object by providing a list of matching AAIDs.
			</li>
			<li>if all entries <code>MetadataStatement.userVerificationDetails[i]</code> only contain 
			  a single entry, then: combine all entries 
			  <code>MetadataStatement.userVerificationDetails[0][0].userVerification</code> to 
			  <code>MetadataStatement.userVerificationDetails[N-1][0].userVerification</code> into 
			  a single value using a bitwise OR operation.
			</li>
		      </ol>
		    </li>
		    <li>if <code>MetadataStatement.userVerificationDetails</code> contains 
		      a single entry, then: combine all entries 
			  <code>MetadataStatement.userVerificationDetails[0][0].userVerification</code> to 
			  <code>MetadataStatement.userVerificationDetails[0][N-1].userVerification</code> into 
			  a single value using a bitwise OR operation and additionally set the flag
			  <code>USER_VERIFY_ALL</code>.
		    </li>
		  </ol>

		  <p>
		    This method doesn't allow matching authenticators
		    implementing complex combinations of user verification methods, such as
		    <code>PIN AND (Fingerprint OR Speaker Recognition)</code> (see above derivation rules).
		    If such specific match rules are required, they need to be specified by providing
		    the AAIDs of the matching authenticators.
		  </p>
		</div></div>

	      </dd><dt id="widl-MatchCriteria-keyProtection"><code>keyProtection</code> of type <span class="idlMemberType">unsigned short</span></dt><dd>A set of 16 bit flags which may be set if
		matching should be restricted by the key protections used (see
		[<cite><a class="bibref" href="#bib-UAFRegistry">UAFRegistry</a></cite>]).
		<p>This match succeeds, if at least one of the bit flags matches the
		  value of <code>AuthenticatorInfo.keyProtection</code> [<cite><a class="bibref" href="#bib-UAFASM">UAFASM</a></cite>].
		</p>
		<div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_24"><span>Note</span></div><p class="">This field corresponds to 
		  <code>MetadataStatement.keyProtection</code> [<cite><a class="bibref" href="#bib-UAFAuthnrMetadata">UAFAuthnrMetadata</a></cite>].
		</p></div> 
	      </dd><dt id="widl-MatchCriteria-matcherProtection"><code>matcherProtection</code> of type <span class="idlMemberType">unsigned short</span></dt><dd>A set of 16 bit flags which may be set if
		matching should be restricted by the matcher protection (see
		[<cite><a class="bibref" href="#bib-UAFRegistry">UAFRegistry</a></cite>]).
		<p>The match succeeds if at least one of the bit flags matches the
		  value of <code>AuthenticatorInfo.matcherProtection</code> [<cite><a class="bibref" href="#bib-UAFASM">UAFASM</a></cite>].
		</p>
		<div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_25"><span>Note</span></div><p class="">This field corresponds to the
		  <code>MetadataStatement.matcherProtection</code> metadata
		  statement. See [<cite><a class="bibref" href="#bib-UAFAuthnrMetadata">UAFAuthnrMetadata</a></cite>].</p></div> 
	      </dd><dt id="widl-MatchCriteria-attachmentHint"><code>attachmentHint</code> of type <span class="idlMemberType">unsigned long</span></dt><dd>A set of 32 bit flags which may be set if matching
		should be restricted by the authenticator attachment
		mechanism (see [<cite><a class="bibref" href="#bib-UAFRegistry">UAFRegistry</a></cite>]).
		<p>This field is considered to match, if at least one
		  of the bit flags matches the value of <code>AuthenticatorInfo.attachmentHint</code> [<cite><a class="bibref" href="#bib-UAFASM">UAFASM</a></cite>].
		</p>
		<div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_26"><span>Note</span></div><p class="">This field corresponds to the 
		  <code>MetadataStatement.attachmentHint</code> metadata
		  statement.</p></div>
	      </dd><dt id="widl-MatchCriteria-tcDisplay"><code>tcDisplay</code> of type <span class="idlMemberType">unsigned short</span></dt><dd>A set of 16 bit flags which may be set if matching
		should be restricted by the transaction confirmation
		display availability and type. (see [<cite><a class="bibref" href="#bib-UAFRegistry">UAFRegistry</a></cite>]).

		<p>This match succeeds if at least one of the bit flags matches the 
		  value of <code>AuthenticatorInfo.tcDisplay</code> [<cite><a class="bibref" href="#bib-UAFASM">UAFASM</a></cite>].
		</p>

		<div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_27"><span>Note</span></div><p class="">This field corresponds to the
		  <code>MetadataStatement.tcDisplay</code> metadata statement. See [<cite><a class="bibref" href="#bib-UAFAuthnrMetadata">UAFAuthnrMetadata</a></cite>]. 
		</p></div>
	      </dd><dt id="widl-MatchCriteria-authenticationAlgorithms"><code>authenticationAlgorithms</code> of type array of <span class="idlMemberType">unsigned short</span></dt><dd>An array containing values of
		supported authentication algorithm TAG values (see
		[<cite><a class="bibref" href="#bib-UAFRegistry">UAFRegistry</a></cite>], prefix <code>UAF_ALG_SIGN</code>) if
		matching should be restricted by the supported
		authentication algorithms.
		<p>This match succeeds if at least one entry in this array matches
		  the <code>AuthenticatorInfo.authenticationAlgorithm</code> [<cite><a class="bibref" href="#bib-UAFASM">UAFASM</a></cite>].
		</p>
		<div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_28"><span>Note</span></div><p class="">This field corresponds to the
		  <code>MetadataStatement.authenticationAlgorithm</code> metadata statement. See [<cite><a class="bibref" href="#bib-UAFAuthnrMetadata">UAFAuthnrMetadata</a></cite>]. 
		</p></div>
	      </dd><dt id="widl-MatchCriteria-assertionSchemes"><code>assertionSchemes</code> of type array of <span class="idlMemberType">DOMString</span></dt><dd>A list of supported assertion
		schemes if matching should be restricted by the supported schemes.
		<p>
		  See section <a href="#uaf-supported-assertion-schemes">UAF Supported 
		  Assertion Schemes</a> for details.</p>
		<p>This match succeeds if at least one entry in this array matches
		  <code>AuthenticatorInfo.assertionScheme</code> [<cite><a class="bibref" href="#bib-UAFASM">UAFASM</a></cite>].
		</p>
		<div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_29"><span>Note</span></div><p class="">This field corresponds to the
		  <code>MetadataStatement.assertionScheme</code> metadata
		  statement. See [<cite><a class="bibref" href="#bib-UAFAuthnrMetadata">UAFAuthnrMetadata</a></cite>].</p></div>
	      </dd><dt id="widl-MatchCriteria-attestationTypes"><code>attestationTypes</code> of type array of <span class="idlMemberType">unsigned short</span></dt><dd>An array containing the preferred attestation
		TAG values (see [<cite><a class="bibref" href="#bib-UAFRegistry">UAFRegistry</a></cite>], prefix <code>TAG_ATTESTATION</code>). 
		The order of items <em class="rfc2119" title="MUST">MUST</em> 
		be preserved. The most-preferred attestation type comes first. 
		<p>This match succeeds if at least one entry in this array matches 
		  one entry in <code>AuthenticatorInfo.attestationTypes</code> [<cite><a class="bibref" href="#bib-UAFASM">UAFASM</a></cite>].
		</p>
		<div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_30"><span>Note</span></div><p class="">This field corresponds to the <code>MetadataStatement.attestationTypes</code> metadata statement. See [<cite><a class="bibref" href="#bib-UAFAuthnrMetadata">UAFAuthnrMetadata</a></cite>]. 
		</p></div>
	      </dd><dt id="widl-MatchCriteria-authenticatorVersion"><code>authenticatorVersion</code> of type <span class="idlMemberType">unsigned short</span></dt><dd>Contains an authenticator version number, if matching should be restricted by the authenticator version in use.
		<p>This match succeeds if the value is <em>lower or equal</em> to 
		  the field <code>AuthenticatorVersion</code> included
		  in <code>TAG_UAFV1_REG_ASSERTION</code> or <code>TAG_UAFV1_AUTH_ASSERTION</code> or
		  a corresponding value in the case of a different assertion scheme.
		</p>
		<div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_31"><span>Note</span></div><div class="">
		  <p>Since the semantic of the <code>authenticatorVersion</code> depends
		    on the AAID, the field <code>authenticatorVersion</code> should always be combined with a single <code>aaid</code>
		    in <code>MatchCriteria</code>.</p>
		  <p>This field corresponds to the 
		    <code>MetadataStatement.authenticatorVersion</code> metadata
		    statement. See [<cite><a class="bibref" href="#bib-UAFAuthnrMetadata">UAFAuthnrMetadata</a></cite>].</p>
		</div></div>
	      </dd><dt id="widl-MatchCriteria-exts"><code>exts</code> of type array of <span class="idlMemberType"><a href="#idl-def-Extension" class="idlType"><code>Extension</code></a></span></dt><dd>Extensions for matching policy.</dd></dl></section>
	    
	</section>
	<section id="policy-dictionary">
	  <h4 aria-level="3" role="heading" id="h4_policy-dictionary"><span class="secno">3.1.12 </span>Policy dictionary</h4>
	  
	  <p>Contains a specification of accepted
	    authenticators and a specification of disallowed
	    authenticators.</p>
	    
	    <pre class="idl"><span class="idlDictionary" id="idl-def-Policy">dictionary <span class="idlDictionaryID">Policy</span> {
<span class="idlMember">    <span class="idlMemberType">required MatchCriteria[][]</span> <span class="idlMemberName"><a href="#widl-Policy-accepted">accepted</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType"><a href="#idl-def-MatchCriteria" class="idlType"><code>MatchCriteria</code></a>[]</span>            <span class="idlMemberName"><a href="#widl-Policy-disallowed">disallowed</a></span>;</span>
};</span></pre><section id="dictionary-policy-members"><h5 aria-level="4" role="heading" id="h5_dictionary-policy-members"><span class="secno">3.1.12.1 </span>Dictionary <a class="idlType" href="#idl-def-Policy"><code>Policy</code></a> Members</h5><dl class="dictionary-members"><dt id="widl-Policy-accepted"><code>accepted</code> of type array of array of <span class="idlMemberType">required MatchCriteria</span></dt><dd>
		<p>This field is a two-dimensional array describing the
		  required authenticator characteristics for the server to accept
		  either a FIDO registration, or authentication operation for a particular purpose.
		</p>
		<p>This two-dimensional array can be seen as a list of sets. List elements
		  (i.e. the sets) are alternatives (OR condition).</p>
		<p>All elements
		  within a set <em class="rfc2119" title="MUST">MUST</em> be combined:</p>
		
		<p>The first array index indicates OR conditions (i.e. the list).
		  Any set of authenticator(s) satisfying these <a title="MatchCriteria" href="#idl-def-MatchCriteria" class="idlType"><code>MatchCriteria</code></a>  in
		  the first index is acceptable to the server for
		  this operation.</p>
		
		<p>Sub-arrays of <a href="#matchcriteria-dictionary">MatchCriteria</a> in the second index (i.e. the set)
		  indicate that multiple authenticators (i.e. each set element)
		  <em class="rfc2119" title="MUST">MUST</em> be registered or authenticated to be accepted by the server.</p>
		
		<p>The <a href="#matchcriteria-dictionary">MatchCriteria</a> array represents ordered preferences by the
		  server. Servers <em class="rfc2119" title="MUST">MUST</em> put their preferred authenticators
		  first, and FIDO UAF Clients <em class="rfc2119" title="SHOULD">SHOULD</em> respect those preferences,
		  either by presenting authenticator
		  options to the user in the same order, or by offering to
		  perform the operation using only the highest-preference authenticator(s).</p>
	      </dd><dt id="widl-Policy-disallowed"><code>disallowed</code> of type array of <span class="idlMemberType"><a href="#idl-def-MatchCriteria" class="idlType"><code>MatchCriteria</code></a></span></dt><dd>Any authenticator that matches
		any of <a href="#matchcriteria-dictionary">MatchCriteria</a> contained
		in the field disallowed <em class="rfc2119" title="MUST">MUST</em> be excluded from
		eligibility for the operation, regardless of whether
		it matches any <a href="#matchcriteria-dictionary">MatchCriteria</a> present in the <code>accepted</code> list, or not.
	      </dd></dl></section>
	</section>
      </section>

      <section class="normativeDisclaimer" id="processing-rules-for-the-server-policy">

	<h3 aria-level="2" role="heading" id="h3_processing-rules-for-the-server-policy"><span class="secno">3.2 </span>Processing Rules for the Server Policy</h3><p><em>This section is normative.</em></p> 

	<p>
	  The FIDO UAF Client <em class="rfc2119" title="MUST">MUST</em> follow the following rules while parsing server
	  policy:
	</p>

	<ol> 
	  <li>During registration:	  

	    <ol> 
	      <li><code>Policy.accepted</code> is a list of combinations. Each combination
		indicates a list of criteria for authenticators that the server
		wants the user to register.</li>
	      
	      <li>Follow the priority of items in <code>Policy.accepted[][]</code>. The lists
		are ordered with highest priority first.</li>
	      
	      <li>Choose the combination whose criteria best match the features of the
		currently available authenticators</li>
	      
	      <li>Collect information about available authenticators</li>
	      
	      <li>Ignore authenticators which match the <code>Policy.disallowed</code> criteria</li>
	      
	      <li>Match collected information with the matching criteria imposed
		in the policy (see <a href="#matchcriteria-dictionary">MatchCriteria 
		dictionary</a> for more details on matching)</li>
	      
	      <li>Guide the user to register the authenticators specified in the
		chosen combination</li>
	    </ol> 
	  </li>
	  
	  <li>During authentication and transaction confirmation:
	    <ol> 
	      <div class="note"><div class="note-title" aria-level="3" role="heading" id="h_note_32"><span>Note</span></div><p class=""><code>Policy.accepted</code> is a list of combinations. Each
		combination indicates a set of criteria which is enough to completely
		authenticate the current pending operation</p></div>
	      
	      <li>Follow the priority of items in <code>Policy.accepted[][]</code>. The lists
		are ordered with highest priority first.</li>
	      
	      <li>Choose the combination whose criteria best match the features of the
		currently available authenticators</li>
	      
	      <li>Collect information about available authenticators</li>
	      
	      <li>Ignore authenticators which meet the <code>Policy.disallowed</code> criteria</li>
	      
	      <li>Match collected information with the matching criteria described
		in the policy</li>
	      
	      <li>Guide the user to authenticate with the authenticators specified
		in the chosen combination</li>
	      
	      <li>A pending operation will be approved by the server only after all
		criteria of a single combination are entirely met</li>
	    </ol>
	  </li>
	</ol>

	<section class="informative" id="examples">    
	  <h4 aria-level="3" role="heading" id="h4_examples"><span class="secno">3.2.1 </span>Examples</h4><p><em>This section is non-normative.</em></p> 
	
	  <div class="example"><div class="example-title"><span>Example 1</span>: Policy matching either a FPS-, or Face
				      Recognition-based Authenticator</div><pre class="example">{
  "accepted": 
  [ 
	[{ "userVerification": 2}],
    	[{ "userVerification": 16}]
  ]
}</pre></div>

	  <div class="example"><div class="example-title"><span>Example 2</span>: Policy matching authenticators
				      implementing FPS and Face Recognition as alternative combination of
				      user verification methods.</div><pre class="example">{
  "accepted": 
  [ 
	[{ "userVerification": 18}]
  ]
}</pre></div>

	  <p>
	    Combining these two bit-flags and the flag <code>USER_VERIFY_ALL</code> (USER_VERIFY_ALL = 1024) into 
	    a single <code>userVerification</code> value would
	    match authenticators implementing FPS and Face Recognition as a <em>mandatory</em> combination of user 
	    verification methods.
	  </p>
	  
	  <div class="example"><div class="example-title"><span>Example 3</span>: Policy matching authenticators
				      implementing FPS and Face Recognition as mandatory combination of
				      user verification methods.</div><pre class="example">{
  "accepted": [ [{ "userVerification": 1042}] ]
}</pre></div>

	  <p>The next example requires two authenticators to be used:</p>
	
	  <div class="example"><div class="example-title"><span>Example 4</span>: Policy matching the combination of a FPS based and a Face Recognition
				      based authenticator</div><pre class="example">{
  "accepted": 
  [ 
	[ 
	  { "userVerification": 2}, 
	  { "userVerification": 16}
	]
  ]
}</pre></div>
	  <p>
	    Other criteria can be specified in addition to the
	    <code>userVerification</code>:</p>
      
	  <div class="example"><div class="example-title"><span>Example 5</span>: Policy requiring the combination of a bound FPS based and 
				      a bound Face Recognition based authenticator</div><pre class="example">{
  "accepted": 
  [ 
	[
	  { "userVerification": 2, "attachmentHint": 1},
	  { "userVerification": 16, "attachmentHint": 1}
        ]
  ]
}</pre></div>

	  <p>The policy for accepting authenticators of vendor with ID <code>1234</code> only is as follows:
      
	    </p><div class="example"><div class="example-title"><span>Example 6</span>: Policy accepting all authenticators from vendor with ID 1234</div><pre class="example">{
  "accepted": 
  [ [{ "vendorID": "1234"}] ]
}</pre></div>

	</section>
      </section>

      <section id="version-negotiation">
      <h3 aria-level="2" role="heading" id="h3_version-negotiation"><span class="secno">3.3 </span>Version Negotiation</h3>
      
      <p>
	The UAF protocol includes multiple versioned constructs:
	UAF protocol version, the
	version of Key Registration Data and Signed Data objects
	(identified by their respective tags, see [<cite><a class="bibref" href="#bib-UAFRegistry">UAFRegistry</a></cite>]), and
	the ASM version, see [<cite><a class="bibref" href="#bib-UAFASM">UAFASM</a></cite>].</p>
      
      <div class="note"><div class="note-title" aria-level="3" role="heading" id="h_note_33"><span>Note</span></div><p class="">
	The Key Registration Data and Signed Data objects have to be parsed
	and verified by the FIDO Server. This verification is only
	possible if the FIDO Server understands their encoding and the
	content. Each UAF protocol version supports a set of
	Key Registration Data and SignedData object versions (called Assertion Schemes). 
	Similarly each of the ASM versions supports a set Assertion Scheme versions.
	
      </p></div><p>
	As a consequence the FIDO UAF Client <em class="rfc2119" title="MUST">MUST</em> select the authenticators
	which will generate the appropriately versioned constructs.
      
      </p><p>
	For version negotiation the FIDO UAF Client <em class="rfc2119" title="MUST">MUST</em> perform the following steps:
	</p><ol>	  
	  <li>Create a set (<code>FC_Version_Set</code>) of version pairs,
            ASM version (<code>asm_version</code>) and UAF Protocol version (<code>upv</code>) and add all pairs
            supported by the FIDO UAF Client into <code>FC_Version_Set</code> 
	    <ul>
              <li>e.g. <code>[{upv1, asm_version1}, {upv2, asm_version1}, ...]</code></li>
	    </ul>
	  </li>
	  <li>Intersect <code>FC_Version_Set</code> with the set of <code>upv</code> included in UAF
	    Message (i.e. keep only those pairs where the <code>upv</code> value is also
	    contained in the UAF Message).</li>
	  
	  <li>Select authenticators which are allowed by the UAF Message Policy.
            For each authenticator:
            <ul>
              <li>Construct a set (<code>Authnr_Version_Set</code>) of version pairs 
		including authenticator supported <code>asm_version</code> and the 
		compatible <code>upv(s)</code>.
              </li>
              <ul>
                <li>e.g. <code>[{upv1, asm_version1}, {upv2, asm_version1}, ...]</code></li>
              </ul>
	      
              <li>Intersect <code>Authnr_Version_Set</code> with <code>FC_Version_Set</code> 
		and select highest version pair from it.</li>
              <ul>
                <li>
                  Take the pair where the <code>upv</code> is highest. In all these 
		  pairs leave only the one with highest <code>asm_version</code>.
                </li>
              </ul>

              <li>Use the remaining version pair with this authenticator</li>
            </ul>
	  </li>	  
	</ol>
	
	<div class="note"><div class="note-title" aria-level="3" role="heading" id="h_note_34"><span>Note</span></div><div class="">
	  <p>Each version consists of <code>major</code> and <code>minor</code> fields.
	    In order to compare two versions - compare the Major fields and if they are equal
	    compare the Minor fields.
	    
          </p><p>Each UAF message contains a version field <code>upv</code>. UAF Protocol
	    version negotiation is always between FIDO UAF Client and FIDO
	    Server.
	</p></div></div>	
      </section>

      <section id="registration-operation"> 
	<h3 aria-level="2" role="heading" id="h3_registration-operation"><span class="secno">3.4 </span>Registration Operation</h3>
	<div class="note"><div class="note-title" aria-level="3" role="heading" id="h_note_35"><span>Note</span></div><div class="">
	  <p>The Registration operation allows the FIDO Server and the FIDO
	    Authenticator to agree on an authentication key.</p>
	  
	  <figure id="fig-uaf-registration-sequence-diagram">	  
            <img src="./img/fido-uaf-protocol-reg-sequence-diagram.png" onerror="./img/fido-uaf-protocol-reg-sequence-diagram.png" alt="UAF Registration Sequence Diagram">
	    <figcaption>Fig. <span class="figno">6</span> <span class="fig-title">UAF Registration Sequence Diagram</span></figcaption>
	  </figure>
	  
	  <p>
	    The following diagram depicts the cryptographic data flow for
	    the registration sequence.</p>
	  
	  <figure id="fig-uaf-registration-cryptographic-data-flow">	  
            <img src="./img/fido-uaf-protocol-reg-sequence-high-level.png" onerror="./img/fido-uaf-protocol-reg-sequence-high-level.png" alt="UAF Registration Cryptographic Data Flow">
	    <figcaption>Fig. <span class="figno">7</span> <span class="fig-title">UAF Registration Cryptographic Data Flow</span></figcaption>
	  </figure>
	  
	  <p>
	    The FIDO Server sends the <code>AppID</code> (see section <a href="#appid-and-facet-id-assertion">AppID and FacetID
	      Assertion</a>), the authenticator <a href="#policy-dictionary">Policy</a>,
	    the <a title="ServerChallenge" href="#idl-def-ServerChallenge" class="idlType"><code>ServerChallenge</code></a> and the <code>Username</code> to the FIDO UAF Client.</p>
	  
	  <p>
	    The FIDO UAF Client computes the <a title="FinalChallengeParams" href="#idl-def-FinalChallengeParams" class="idlType"><code>FinalChallengeParams</code></a> (FCH) from
	    the <a title="ServerChallenge" href="#idl-def-ServerChallenge" class="idlType"><code>ServerChallenge</code></a> and some other values 
	    and sends the <code>AppID</code>, the <code>FCH</code> and the
	    <code>Username</code> to the authenticator.</p>
	  
	  <p>
	    The authenticator creates a Key Registration Data object (e.g. <code>TAG_UAFV1_KRD</code>,
	    see [<cite><a class="bibref" href="#bib-UAFAuthnrCommands">UAFAuthnrCommands</a></cite>]) containing the hash of <code>FCH</code>, the newly
	    generated user public key (UAuth.pub) and some other values and
	    signs it (see section <a href="#authenticator-attestation">Authenticator Attestation</a> 
	    for more details). This KRD object is then
	    cryptographically verified by the FIDO Server.</p>
	</div></div>
	<section id="registration-request-message">

        <h4 aria-level="3" role="heading" id="h4_registration-request-message"><span class="secno">3.4.1 </span>Registration Request Message</h4>

        <p>
            UAF Registration request message is represented as an array of dictionaries. Each dictionary contains an
            registration request for a specific protocol version. The array <em class="rfc2119" title="MUST NOT">MUST NOT</em> contain two dictionaries of the
            same protocol version. For version "1.0" the request is defined as
            <a href="#idl-def-RegistrationRequest">RegistrationRequest</a> dictionary.
        </p>

	   <div class="example"><div class="example-title"><span>Example 7</span>: UAF Registration Request</div><pre class="example">[{
    "header": {
      "upv": {
        "major": 1,
        "minor": 0
      },
      "op": "Reg",
 "appID": "https://uaf-test-1.noknoktest.com:8443/SampleApp/uaf/facets",
      "serverData": "IjycjPZYiWMaQ1tKLrJROiXQHmYG0tSSYGjP5mgjsDaM17RQgq0
dl3NNDDTx9d-aSR_6hGgclrU2F2Yj-12S67v5VmQHj4eWVseLulHdpk2v_hHtKSvv_DFqL4n
2IiUY6XZWVbOnvg"
    },
    "challenge": "H9iW9yA9aAXF_lelQoi_DhUk514Ad8Tqv0zCnCqKDpo",
    "username": "apa",
    "policy": {
      "accepted": [
        [
          {
            "userVerification": 512,
            "keyProtection": 1,
            "tcDisplay": 1,
            "authenticationAlgorithms": [
              1
            ],
            "assertionSchemes": [
              "UAFV1TLV"
            ]
          }
        ],
        [
          {
            "userVerification": 4,
            "keyProtection": 1,
            "tcDisplay": 1,
            "authenticationAlgorithms": [
              1
            ],
            "assertionSchemes": [
              "UAFV1TLV"
            ]
          }
        ],
        [
          {
            "userVerification": 4,
            "keyProtection": 1,
            "tcDisplay": 1,
            "authenticationAlgorithms": [
              2
            ]
          }
        ],
        [
          {
            "userVerification": 2,
            "keyProtection": 4,
            "tcDisplay": 1,
            "authenticationAlgorithms": [
              2
            ]
          }
        ],
        [
          {
            "userVerification": 4,
            "keyProtection": 2,
            "tcDisplay": 1,
            "authenticationAlgorithms": [
              1,
              3
            ]
          }
        ],
        [
          {
            "userVerification": 2,
            "keyProtection": 2,
            "authenticationAlgorithms": [
              2
            ]
          }
        ],
        [
          {
            "userVerification": 32,
            "keyProtection": 2,
            "assertionSchemes": [
              "UAFV1TLV"
            ]
          },
          {
            "userVerification": 2,
            "authenticationAlgorithms": [
              1,
              3
            ],
            "assertionSchemes": [
              "UAFV1TLV"
            ]
          },
          {
            "userVerification": 2,
            "authenticationAlgorithms": [
              1,
              3
            ],
            "assertionSchemes": [
              "UAFV1TLV"
            ]
          },
          {
            "userVerification": 4,
            "keyProtection": 1,
            "authenticationAlgorithms": [
              1,
              3
            ],
            "assertionSchemes": [
              "UAFV1TLV"
            ]
          }
        ]
      ],
      "disallowed": [
        {
          "userVerification": 512,
          "keyProtection": 16,
          "assertionSchemes": [
            "UAFV1TLV"
          ]
        },
        {
          "userVerification": 256,
          "keyProtection": 16
        },
        {
          "aaid": [
            "ABCD#ABCD"
          ],
          "keyIDs": [
            "RfY_RDhsf4z5PCOhnZExMeVloZZmK0hxaSi10tkY_c4"
          ]
        }
      ]
    }
}]</pre></div>	   	   
	</section>
	
	<section id="registrationrequest-dictionary"> 
	  <h4 aria-level="3" role="heading" id="h4_registrationrequest-dictionary"><span class="secno">3.4.2 </span>RegistrationRequest dictionary</h4>
	  <p>RegistrationRequest contains a single, versioned, registration request.</p>
	    
	  <pre class="idl"><span class="idlDictionary" id="idl-def-RegistrationRequest">dictionary <span class="idlDictionaryID">RegistrationRequest</span> {
<span class="idlMember">    <span class="idlMemberType">required OperationHeader</span> <span class="idlMemberName"><a href="#widl-RegistrationRequest-header">header</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">required ServerChallenge</span> <span class="idlMemberName"><a href="#widl-RegistrationRequest-challenge">challenge</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">required DOMString</span>       <span class="idlMemberName"><a href="#widl-RegistrationRequest-username">username</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">required Policy</span>          <span class="idlMemberName"><a href="#widl-RegistrationRequest-policy">policy</a></span>;</span>
};</span></pre><section id="dictionary-registrationrequest-members"><h5 aria-level="4" role="heading" id="h5_dictionary-registrationrequest-members"><span class="secno">3.4.2.1 </span>Dictionary <a class="idlType" href="#idl-def-RegistrationRequest"><code>RegistrationRequest</code></a> Members</h5><dl class="dictionary-members"><dt id="widl-RegistrationRequest-header"><code>header</code> of type <span class="idlMemberType">required OperationHeader</span></dt><dd>Operation header.  <code>Header.op</code> <em class="rfc2119" title="MUST">MUST</em> be "Reg"</dd><dt id="widl-RegistrationRequest-challenge"><code>challenge</code> of type <span class="idlMemberType">required ServerChallenge</span></dt><dd>Server-provided challenge value</dd><dt id="widl-RegistrationRequest-username"><code>username</code> of type <span class="idlMemberType">required DOMString</span></dt><dd><code>string[1..128]</code>
	      <p>A human-readable user name intended to allow the
		user to distinguish and select from among
		different accounts at the same relying party</p></dd><dt id="widl-RegistrationRequest-policy"><code>policy</code> of type <span class="idlMemberType">required Policy</span></dt><dd>Describes which types of authenticators are acceptable
	      for this registration operation</dd></dl></section>
	  
	</section>
	<section id="authenticatorregistrationassertion-dictionary">
	  <h4 aria-level="3" role="heading" id="h4_authenticatorregistrationassertion-dictionary"><span class="secno">3.4.3 </span>AuthenticatorRegistrationAssertion dictionary</h4>
	  <p>
	    Contains the authenticator's response to a RegistrationRequest message:
	    
	    </p><pre class="idl"><span class="idlDictionary" id="idl-def-AuthenticatorRegistrationAssertion">dictionary <span class="idlDictionaryID">AuthenticatorRegistrationAssertion</span> {
<span class="idlMember">    <span class="idlMemberType">required DOMString</span>                    <span class="idlMemberName"><a href="#widl-AuthenticatorRegistrationAssertion-assertionScheme">assertionScheme</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">required DOMString</span>                    <span class="idlMemberName"><a href="#widl-AuthenticatorRegistrationAssertion-assertion">assertion</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">DisplayPNGCharacteristicsDescriptor[]</span> <span class="idlMemberName"><a href="#widl-AuthenticatorRegistrationAssertion-tcDisplayPNGCharacteristics">tcDisplayPNGCharacteristics</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType"><a href="#idl-def-Extension" class="idlType"><code>Extension</code></a>[]</span>                           <span class="idlMemberName"><a href="#widl-AuthenticatorRegistrationAssertion-exts">exts</a></span>;</span>
};</span></pre><section id="dictionary-authenticatorregistrationassertion-members"><h5 aria-level="4" role="heading" id="h5_dictionary-authenticatorregistrationassertion-members"><span class="secno">3.4.3.1 </span>Dictionary <a class="idlType" href="#idl-def-AuthenticatorRegistrationAssertion"><code>AuthenticatorRegistrationAssertion</code></a> Members</h5><dl class="dictionary-members"><dt id="widl-AuthenticatorRegistrationAssertion-assertionScheme"><code>assertionScheme</code> of type <span class="idlMemberType">required DOMString</span></dt><dd>The name of the Assertion Scheme used to encode the <code>assertion</code>. See
		<a href="#uaf-supported-assertion-schemes">UAF Supported Assertion Schemes</a> for details.
		<div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_36"><span>Note</span></div><p class="">This assertionScheme is not part of a signed object and hence considered 
		  the <i>suspected</i> assertionScheme.</p></div>
	      </dd><dt id="widl-AuthenticatorRegistrationAssertion-assertion"><code>assertion</code> of type <span class="idlMemberType">required DOMString</span></dt><dd><code>base64url(byte[1..4096])</code>
		Contains the <code>TAG_UAFV1_REG_ASSERTION</code> object containing 
		the assertion scheme specific 
		KeyRegistrationData (KRD) object which in turn contains the newly 
		generated <code>UAuth.pub</code> and is signed by the
		Attestation Private Key. 
		<p>This assertion <em class="rfc2119" title="MUST">MUST</em> be generated by the
		  authenticator and it <em class="rfc2119" title="MUST">MUST</em> be used only in this Registration operation.
		  The format of this assertion can vary from one assertion scheme to another
		  (e.g. for "UAFV1TLV" assertion scheme it <em class="rfc2119" title="MUST">MUST</em> be <code>TAG_UAFV1_KRD</code>).</p>
	      </dd><dt id="widl-AuthenticatorRegistrationAssertion-tcDisplayPNGCharacteristics"><code>tcDisplayPNGCharacteristics</code> of type array of <span class="idlMemberType">DisplayPNGCharacteristicsDescriptor</span></dt><dd>Supported transaction PNG type [<cite><a class="bibref" href="#bib-UAFAuthnrMetadata">UAFAuthnrMetadata</a></cite>].
		For the definition of the DisplayPNGCharacteristicsDescriptor structure See [<cite><a class="bibref" href="#bib-UAFAuthnrMetadata">UAFAuthnrMetadata</a></cite>].
	      </dd><dt id="widl-AuthenticatorRegistrationAssertion-exts"><code>exts</code> of type array of <span class="idlMemberType"><a href="#idl-def-Extension" class="idlType"><code>Extension</code></a></span></dt><dd>Contains Extensions prepared by the authenticator</dd></dl></section>
	    
	</section>
	<section id="registration-response-message">
          <h4 aria-level="3" role="heading" id="h4_registration-response-message"><span class="secno">3.4.4 </span>Registration Response Message</h4>

          <p>
            A UAF Registration response message is represented as an
            array of dictionaries. Each dictionary contains a
            registration response for a specific protocol version. The
            array <em class="rfc2119" title="MUST NOT">MUST NOT</em> contain two dictionaries of the same
            protocol version. For version "1.0" the response is
            defined as
            <a href="#idl-def-RegistrationResponse">RegistrationResponse</a> dictionary.
          </p>

	  <div class="example"><div class="example-title"><span>Example 8</span>: Registration Response</div><pre class="example">[{
    "assertions": [
      {
        "assertion": "AT7uAgM-sQALLgkAQUJDRCNBQkNEDi4HAAABAQEAAAEKLiAA9t
BzZC64ecgVQBGSQb5QtEIPC8-Vav4HsHLZDflLaugJLiAAZMCPn92yHv1Ip-iCiBb6i4ADq6
ZOv569KFQCvYSJfNgNLggAAQAAAAEAAAAMLkEABJsvEtUsVKh7tmYHhJ2FBm3kHU-OCdWiUY
VijgYa81MfkjQ1z6UiHbKP9_nRzIN9anprHqDGcR6q7O20q_yctZAHPjUCBi5AACv8L7YlRM
x10gPnszGO6rLFqZFmmRkhtV0TIWuWqYxd1jO0wxam7i5qdEa19u4sfpHFZ9RGI_WHxINkH8
FfvAwFLu0BMIIB6TCCAY8CAQEwCQYHKoZIzj0EATB7MQswCQYDVQQGEwJVUzELMAkGA1UECA
wCQ0ExCzAJBgNVBAcMAlBBMRAwDgYDVQQKDAdOTkwsSW5jMQ0wCwYDVQQLDAREQU4xMRMwEQ
YDVQQDDApOTkwsSW5jIENBMRwwGgYJKoZIhvcNAQkBFg1ubmxAZ21haWwuY29tMB4XDTE0MD
gyODIxMzU0MFoXDTE3MDUyNDIxMzU0MFowgYYxCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQT
EWMBQGA1UEBwwNU2FuIEZyYW5jaXNjbzEQMA4GA1UECgwHTk5MLEluYzENMAsGA1UECwwERE
FOMTETMBEGA1UEAwwKTk5MLEluYyBDQTEcMBoGCSqGSIb3DQEJARYNbm5sQGdtYWlsLmNvbT
BZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABCGBt3CIjnDowzSiF68C2aErYXnDUsWXOYxqIP
im0OWg9FFdUYCa6AgKjn1R99Ek2d803sGKROivnavmdVH-SnEwCQYHKoZIzj0EAQNJADBGAi
EAzAQujXnSS9AIAh6lGz6ydypLVTsTnBzqGJ4ypIqy_qUCIQCFsuOEGcRV-o4GHPBph_VMrG
3NpYh2GKPjsAim_cSNmQ",
        "assertionScheme": "UAFV1TLV"
      }
    ],
    "fcParams": "eyJhcHBJRCI6Imh0dHBzOi8vdWFmLXRlc3QtMS5ub2tub2t0ZXN0LmN
vbTo4NDQzL1NhbXBsZUFwcC91YWYvZmFjZXRzIiwiY2hhbGxlbmdlIjoiSDlpVzl5QTlhQVh
GX2xlbFFvaV9EaFVrNTE0QWQ4VHF2MHpDbkNxS0RwbyIsImNoYW5uZWxCaW5kaW5nIjp7fSw
iZmFjZXRJRCI6ImNvbS5ub2tub2suYW5kcm9pZC5zYW1wbGVhcHAifQ",
    "header": {
 "appID": "https://uaf-test-1.noknoktest.com:8443/SampleApp/uaf/facets",
      "op": "Reg",
      "serverData": "IjycjPZYiWMaQ1tKLrJROiXQHmYG0tSSYGjP5mgjsDaM17RQgq0
dl3NNDDTx9d-aSR_6hGgclrU2F2Yj-12S67v5VmQHj4eWVseLulHdpk2v_hHtKSvv_DFqL4n
2IiUY6XZWVbOnvg",
      "upv": {
        "major": 1,
        "minor": 0
      }
    }
}]</pre></div>
	  <div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_37"><span>Note</span></div><p class="">Line breaks in fcParams have been inserted for improving readability.</p></div>
	</section>
	<section id="registrationresponse-dictionary">
	  <h4 aria-level="3" role="heading" id="h4_registrationresponse-dictionary"><span class="secno">3.4.5 </span>RegistrationResponse dictionary</h4>
	  <p>Contains all fields related to the registration response.</p>
	    
	    <pre class="idl"><span class="idlDictionary" id="idl-def-RegistrationResponse">dictionary <span class="idlDictionaryID">RegistrationResponse</span> {
<span class="idlMember">    <span class="idlMemberType">required OperationHeader</span>                      <span class="idlMemberName"><a href="#widl-RegistrationResponse-header">header</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">required DOMString</span>                            <span class="idlMemberName"><a href="#widl-RegistrationResponse-fcParams">fcParams</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">required AuthenticatorRegistrationAssertion[]</span> <span class="idlMemberName"><a href="#widl-RegistrationResponse-assertions">assertions</a></span>;</span>
};</span></pre><section id="dictionary-registrationresponse-members"><h5 aria-level="4" role="heading" id="h5_dictionary-registrationresponse-members"><span class="secno">3.4.5.1 </span>Dictionary <a class="idlType" href="#idl-def-RegistrationResponse"><code>RegistrationResponse</code></a> Members</h5><dl class="dictionary-members"><dt id="widl-RegistrationResponse-header"><code>header</code> of type <span class="idlMemberType">required OperationHeader</span></dt><dd><code>Header.op</code> <em class="rfc2119" title="MUST">MUST</em> be "Reg".</dd><dt id="widl-RegistrationResponse-fcParams"><code>fcParams</code> of type <span class="idlMemberType">required DOMString</span></dt><dd>The base64url-encoded serialized [<cite><a class="bibref" href="#bib-RFC4627">RFC4627</a></cite>]
		<a title="FinalChallengeParams" href="#idl-def-FinalChallengeParams" class="idlType"><code>FinalChallengeParams</code></a>
		using UTF8 encoding (see <a href="#finalchallenge-dictionary">FinalChallengeParams dictionary</a>) 
		which contains all parameters required
		for the server to verify the Final Challenge.</dd><dt id="widl-RegistrationResponse-assertions"><code>assertions</code> of type array of <span class="idlMemberType">required AuthenticatorRegistrationAssertion</span></dt><dd>Response data for each Authenticator being registered.</dd></dl></section>	     
	</section> 
	<section id="registration-processing-rules">
	  <h4 aria-level="3" role="heading" id="h4_registration-processing-rules"><span class="secno">3.4.6 </span>Registration Processing Rules</h4>
	  <section id="registration-request-generation-rules-for-fido-server">
	    <h5 aria-level="4" role="heading" id="h5_registration-request-generation-rules-for-fido-server"><span class="secno">3.4.6.1 </span>Registration Request Generation Rules for FIDO Server</h5>
	    
	    <p>
	      The policy contains a two-dimensional array of allowed
	      <a href="#idl-def-MatchCriteria" class="idlType"><code>MatchCriteria</code></a> (see <a href="#policy-dictionary">Policy</a>). This array can be
	      considered a list (first dimension) of sets (second dimension)
	      of authenticators (identified by <code>MatchCriteria</code>). All
	      authenticators in a specific set <em class="rfc2119" title="MUST">MUST</em> be registered
	      simultaneously in order to match the policy. But any of those
	      sets in the list are valid, as the list elements are
	      alternatives.</p>
	    
            <p>The FIDO Server <em class="rfc2119" title="MUST">MUST</em> follow the following steps:</p>
	    <ol>
	      <li>Construct appropriate authentication policy <code>p</code>
		<ol>
		  <li>for each set of alternative authenticators do
		    <ol>
		      <li>Create an array of
			MatchCriteria objects, containing the set of
			authenticators to be registered simultaneously
			that need to be identified by <i>separate</i> MatchCriteria objects <code>m</code>.		    
			<ol> 
      			  <li>For each collection of authenticators <code>a</code> to
      			    be registered simultaneously that can be
      			    identified by the <i>same rule</i>, create a 
			    MatchCriteria object <code>m</code>, where
			    <ul>
      			      <li><code>m.aaid</code> <em class="rfc2119" title="MAY">MAY</em> be combined with (one or more of) <code>m.keyIDs</code>, 
				<code>m.attachmentHint</code>, <code>m.authenticatorVersion</code>, 
				and <code>m.exts</code>, but <code>m.aaid</code> 
				<em class="rfc2119" title="MUST NOT">MUST NOT</em> be combined with any other match criteria field.
			      </li>
      			      <li>If <code>m.aaid</code> is not provided - 
				at least <code>m.authenticationAlgorithms</code> and
				<code>m.assertionSchemes</code> <em class="rfc2119" title="MUST">MUST</em> be provided</li>
			    </ul>
			  </li>
			  <li>Add <code>m</code> to <code>v</code>, e.g. <code>v[j+1]=m</code>.</li>
			</ol> 
		      </li>
		      <li>Add <code>v</code> to <code>p.allowed</code>, e.g. <code>p.allowed[i+1]=v</code></li>
		    </ol>
		  </li>
		  <li>Create MatchCriteria objects <code>m[]</code> for all disallowed Authenticators.
		    <ol>
                      <li>For each already registered AAID for the current user
			<ol>
			  <li>Create a MatchCriteria object <code>m</code> and
			    add AAID and corresponding KeyIDs to 
			    <code>m.aaid</code> and <code>m.KeyIDs</code>.</li>
			  <p>The FIDO Server <em class="rfc2119" title="MUST">MUST</em> include already registered
			    AAIDs and KeyIDs into field <code>p.disallowed</code> to hint that the client 
			    should not register these again.</p>
			</ol>
                      </li>
                      <li>Create a MatchCriteria object <code>m</code> and
			add the AAIDs of all disallowed Authenticators
			to <code>m.aaid</code>.
			<p>The status (as provided in the metadata 
			  TOC (Table-of-Contents file) [<cite><a class="bibref" href="#bib-UAFMetadataService">UAFMetadataService</a></cite>]) of
			  some authenticators might be unacceptable. Such authenticators <em class="rfc2119" title="SHOULD">SHOULD</em>
			  be included in <code>p.disallowed</code>. </p>
                      </li>
                      <li>If needed - create MatchCriteria <code>m</code> for other disallowed criteria
			(e.g. unsupported authenticationAlgs)</li>
                      <li>Add all <code>m</code> to <code>p.disallowed</code>.</li>
		    </ol>
		  </li>
		</ol>
	      </li>
      	      <li>Create a <code>RegistrationRequest</code> object <code>r</code> with appropriate <code>r.header</code> for each supported version, and
		<ol>
		  <li>FIDO Servers <em class="rfc2119" title="SHOULD NOT">SHOULD NOT</em> assume any implicit integrity protection 
		    of <code>r.header.serverData</code>.

		    <p>
		      FIDO Servers that depend on the integrity of <code>r.header.serverData</code> <em class="rfc2119" title="SHOULD">SHOULD</em>
		      apply and verify a cryptographically secure Message
		      Authentication Code (MAC) to serverData and they <em class="rfc2119" title="SHOULD">SHOULD</em> also cryptographically bind serverData to 
		      the related message, e.g. by re-including <code>r.challenge</code>, see also section
		      <a href="#serverdata-and-keyhandle">ServerData and KeyHandle</a>.
		    </p>

		    <div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_38"><span>Note</span></div><p class="">All other FIDO components (except the FIDO server) will treat
		      <code>r.header.serverData</code> as an opaque value.  As a consequence
		      the FIDO server can implement any suitable cryptographic protection method.</p></div>
		  </li>
      		  <li>Generate a random challenge and assign it to  <code>r.challenge</code></li>
      		  <li>Assign the username of the user to be registered to  <code>r.username</code></li>
      		  <li>Assign  <code>p</code> to  <code>r.policy</code>.</li>
      		  <li>Append  <code>r</code> to the array  <code>o</code> of message with various versions 
		    (<code>RegistrationRequest</code>)</li>
		</ol>
	      </li>
      	      <li>Send <code>o</code> to the FIDO UAF Client</li>
	    </ol>
	  </section>

	  <section id="registration-request-processing-rules-for-fido-uaf-clients"> 

	    <h5 aria-level="4" role="heading" id="h5_registration-request-processing-rules-for-fido-uaf-clients"><span class="secno">3.4.6.2 </span>Registration Request Processing Rules for FIDO UAF Clients</h5>
      
	    <p>The FIDO UAF Client <em class="rfc2119" title="MUST">MUST</em> perform the following steps:</p>
	    
	    <ol> 
	      <li>Choose the message <code>m</code> with major version <code>1</code> 
		and minor version <code>0</code></li>
	      <li> Parse the message  <code>m</code></li>
	      <li>If a mandatory field in UAF message is not present or a field
		doesn't correspond to its type and value - reject the operation</li>
	      <li>Filter the available authenticators with the given policy and
		present the filtered authenticators to User. Make sure to not
		include already registered authenticators for this user
		specified in <code>RegRequest.policy.disallowed[].keyIDs</code></li>
	      <li>Obtain <code>FacetID</code> of the requesting Application. If the <code>AppID</code> is missing or
		empty, set the <code>AppID</code> to the <code>FacetID</code>.
		<p>Verify that the <code>FacetID</code> is authorized for the <code>AppID</code> 
		  according to the algorithms in [<cite><a class="bibref" href="#bib-FIDOAppIDAndFacets">FIDOAppIDAndFacets</a></cite>].</p>
  		<ul> 
		  <li>If the <code>FacetID</code> of the requesting Application is not authorized, reject the operation</li>
		</ul> 
	      </li>
	      <li>Obtain TLS data if it is available</li>
	      <li>Create a <a title="FinalChallengeParams" href="#idl-def-FinalChallengeParams" class="idlType"><code>FinalChallengeParams</code></a> 
		structure <code>fcp</code> and set <code>fcp.appID</code>,
		<code>fcp.challenge</code>, <code>fcp.facetID</code>, and 
		<code>fcp.channelBinding</code> appropriately.
		Serialize [<cite><a class="bibref" href="#bib-RFC4627">RFC4627</a></cite>] fcp using UTF8 encoding and base64url
		encode it.
		<ul> 
  		  <li><code>FinalChallenge = base64url(serialize(utf8encode(fcp)))</code></li>
		</ul>
	      </li>
              <li>For each authenticator that matches UAF protocol version (see
		section <a href="#version-negotiation">Version Negotiation</a>) and user agrees to register:
		<ol>
		  <li>Add <code>AppID</code>, <code>Username</code>, <code>FinalChallenge</code>, <code>AttestationType</code>
		    and all other required fields to the ASMRequest [<cite><a class="bibref" href="#bib-UAFASM">UAFASM</a></cite>].</li>
		  <p>The FIDO UAF Client <em class="rfc2119" title="MUST">MUST</em> follow the server policy and find the single preferred attestation type.
		    A single attestation type <em class="rfc2119" title="MUST">MUST</em> be provided to the ASM.</p>
		  <li>Send ASMRequest to the ASM</li>
		</ol>
	      </li>
	    </ol>
	  </section>

	  <section id="registration-request-processing-rules-for-fido-authenticator">
	    <h5 aria-level="4" role="heading" id="h5_registration-request-processing-rules-for-fido-authenticator"><span class="secno">3.4.6.3 </span>Registration Request Processing Rules for FIDO Authenticator</h5>
      
	    <p>See [<cite><a class="bibref" href="#bib-UAFAuthnrCommands">UAFAuthnrCommands</a></cite>], section "Register Command".
	  </p></section>

	  <section id="registration-response-generation-rules-for-fido-uaf-client">
	    <h5 aria-level="4" role="heading" id="h5_registration-response-generation-rules-for-fido-uaf-client"><span class="secno">3.4.6.4 </span>Registration Response Generation Rules for FIDO UAF Client</h5>
	    The FIDO UAF Client <em class="rfc2119" title="MUST">MUST</em> follow the steps:
	    <ol> 
	      <li>Create a <code>RegistrationResponse</code> message</li>
	      <li>Copy <code>RegistrationRequest.header</code> into <code>RegistrationResponse.header</code></li>
	      <li>Set <code>RegistrationResponse.fcParams</code> to <code>FinalChallenge</code> (base64url
		encoded serialized and utf8 encoded FinalChallengeParams)</li>
	      <li>Append the response from each Authenticator into
		<code>RegistrationResponse.assertions</code></li>
	      <li>Send <code>RegistrationResponse</code> message to FIDO Server</li>
	    </ol>
	  </section>
	  <section id="registration-response-processing-rules-for-fido-server">
	    <h5 aria-level="4" role="heading" id="h5_registration-response-processing-rules-for-fido-server"><span class="secno">3.4.6.5 </span>Registration Response Processing Rules for FIDO Server</h5>
	    
	    <div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_39"><span>Note</span></div><p class="">
              The following processing rules assume that Authenticator supports "UAFV1TLV" assertion scheme.
              Currently "UAFV1TLV" is the only defined and supported assertion scheme. When a new 
	      assertion scheme is added to UAF protocol - this section will be extended 
	      with corresponding processing rules.
	    </p></div>
	    
	    <p>The FIDO Server <em class="rfc2119" title="MUST">MUST</em> follow the steps:
	      </p><ol> 
		<li>Parse the message
		  <ol>
      		    <li>If protocol version (<code>RegistrationResponse.header.upv</code>) is not
		      supported – reject the operation</li>
      		    <li>If a mandatory field in UAF message is not present or a field
		      doesn't correspond to its type and value - reject the operation</li>
		  </ol>
		</li>
		<li>Verify that <code>RegistrationResponse.header.serverData</code>, if used,
		  passes any implementation-specific checks against its validity. See also section
		  <a href="#serverdata-and-keyhandle">ServerData and KeyHandle</a>.
		</li>
		<li>base64url decode <code>RegistrationResponse.fcParams</code> and convert it
		  into an object (<code>fcp</code>)</li>
		<li> Verify each field in fcp and make sure it is valid:
		  <ol> 
      		    <li>Make sure <code>fcp.appID</code> corresponds to the one stored by the FIDO Server</li>
      		    <li>Make sure <code>fcp.challenge</code> has really been generated by the FIDO Server
		      for this operation and it is not expired</li>
      		    <li>Make sure <code>fcp.facetID</code> is in the list of trusted FacetIDs [<cite><a class="bibref" href="#bib-FIDOAppIDAndFacets">FIDOAppIDAndFacets</a></cite>]</li>
      		    <li>Make sure <code>fcp.channelBinding</code> is as expected (see 
		      section <a href="#channelbinding-dictionary">ChannelBinding dictionary</a>)</li>
      		    <li>Reject the response if any of these checks fails</li>
		  </ol>
		</li>
		<li>For each assertion <code>a</code> in <code>RegistrationResponse.assertions</code>
		  <ol>
      		    <li>Parse TLV data from <code>a.assertion</code> assuming it is encoded according to 
		      the suspected assertion scheme <code>a.assertionScheme</code> and make sure it 
		      contains all mandatory fields (indicated in Authenticator Metadata) it is supposed to
		      have and has a valid syntax.
		      <ul> 
			<li>If it doesn't - continue with next assertion</li>
		      </ul>
		    </li>
		    <li>Retrieve the AAID from the assertion. 
		      <div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_40"><span>Note</span></div><p class="">The AAID in <code>TAG_UAFV1_KRD</code> is contained 
			in <code>a.assertion.TAG_UAFV1_REG_ASSERTION.TAG_UAFV1_KRD.TAG_AAID</code>.</p></div>
		    </li>
		    <li>Verify that <code>a.assertionScheme</code> matches <code>Metadata(AAID).assertionScheme</code>
		      <ul> 
			<li>If it doesn't match - continue with next assertion</li>
		      </ul>
		    </li>
		    <li>Verify that the AAID indeed matches the policy specified
		      in the registration request.
		      <div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_41"><span>Note</span></div><p class="">Depending on the policy (e.g. in the case of AND combinations), it 
			might be required to evaluate other assertions included in this <code>RegistrationResponse</code> in 
			order to determine whether this AAID matches the policy.</p></div>
		      <ul> 
			<li>If it doesn't match the policy - continue with next assertion</li>
		      </ul> 
		    </li>
      		    <li>Locate authenticator-specific authentication algorithms from
		      the authenticator metadata [<cite><a class="bibref" href="#bib-UAFAuthnrMetadata">UAFAuthnrMetadata</a></cite>] using the AAID.</li>
      		    <li>Hash <code>RegistrationResponse.fcParams</code> using hashing algorithm
		      suitable for this authenticator type. Look up the hash
		      algorithm in authenticator metadata, field <code>AuthenticationAlgs</code>.
		      It is the hash algorithm associated with the first entry
		      related to a constant with prefix UAF_ALG_SIGN.
		      <ul>
			<li><code>FCHash = hash(RegistrationResponse.fcParams)</code></li>
		      </ul> 
		    </li>
		    <li>if <code>a.assertion</code> contains an object of type <code>TAG_UAFV1_REG_ASSERTION</code>, then
		      <ol>
			<li>if <code>a.assertion.TAG_UAFV1_REG_ASSERTION</code> contains 
			  <code>TAG_UAFV1_KRD</code> as first element:
			  <ol>	      
			    <li>Obtain <code>Metadata(AAID).AttestationType</code> for the AAID and make sure 
			      that <code>a.assertion.TAG_UAFV1_REG_ASSERTION</code> contains the most preferred
			      attestation tag specified in field <code>MatchCriteria.attestationTypes</code> 
			      in <code>RegistrationRequest.policy</code> (if this field is present).
			      <ul>
				<li>If <code>a.assertion.TAG_UAFV1_REG_ASSERTION</code> doesn't contain the 
				  preferred attestation - it is <em class="rfc2119" title="RECOMMENDED">RECOMMENDED</em> to skip this
				  assertion and continue with next one</li>
			      </ul>
			    </li>
			    <li>Make sure that <code>a.assertion.TAG_UAFV1_REG_ASSERTION.TAG_UAFV1_KRD.FinalChallenge</code> 
			      == <code>FCHash</code>
			      <ul> 
				<li>If comparison fails - continue with next assertion</li>
			      </ul> 
			    </li>
			    <li>Obtain <code>Metadata(AAID).AuthenticatorVersion</code> for the AAID 
			      and make sure that it is lower or equal to 
			      <code>a.assertion.TAG_UAFV1_REG_ASSERTION.TAG_UAFV1_KRD.AuthenticatorVersion</code>.
			      <ul>
				<li>If <code>Metadata(AAID).AuthenticatorVersion</code> is higher (i.e. the 
				  authenticator firmware is outdated), 
				  it is <em class="rfc2119" title="RECOMMENDED">RECOMMENDED</em> to assume increased risk.
				  See sections "StatusReport dictionary" and "Metadata TOC object Processing Rules" 
				  in [<cite><a class="bibref" href="#bib-UAFMetadataService">UAFMetadataService</a></cite>] for more details on this.
				</li>
			      </ul>
			    </li>
			    <li>Check whether <code>a.assertion.TAG_UAFV1_REG_ASSERTION.TAG_UAFV1_KRD.RegCounter</code> 
			      is acceptable, i.e. it is either not supported (value is 0) or it is not exceedingly high
			      <ul>
				<li>If <code>a.assertion.TAG_UAFV1_REG_ASSERTION.TAG_UAFV1_KRD.RegCounter</code> 
				  is exceedingly high, this assertion might be skipped
				  and processing will continue with next one</li>
			      </ul>
			    </li>
			    <li>If <code>a.assertion.TAG_UAFV1_REG_ASSERTION.TAG_UAFV1_KRD</code> 
			      contains <code>TAG_ATTESTATION_BASIC_FULL</code> tag
			      <ol>
				<li>If entry <code>AttestationRootCertificates</code> for the AAID in the
				  metadata [<cite><a class="bibref" href="#bib-UAFAuthnrMetadata">UAFAuthnrMetadata</a></cite>] contains at least one element:
				  <ol>
				    <li>Obtain contents of all <code>TAG_ATTESTATION_CERT</code> tags from
				      <code>a.assertion.TAG_UAFV1_REG_ASSERTION.TAG_ATTESTATION_BASIC_FULL</code> object. 
				      The occurrences are ordered (see [<cite><a class="bibref" href="#bib-UAFAuthnrCommands">UAFAuthnrCommands</a></cite>])
				      and represent the attestation certificate followed by the related 
				      certificate chain.</li>
				    <li>Obtain all entries of <code>AttestationRootCertificates</code>
				      for the AAID in authenticator Metadata, field <code>AttestationRootCertificates</code>.</li>
				    <li>Verify the attestation certificate and the entire certificate chain up to
				      the Attestation Root Certificate using Certificate Path
				      Validation as specified in [<cite><a class="bibref" href="#bib-RFC5280">RFC5280</a></cite>]</li>
				    <ul>
				      <li>If verification fails – continue with next assertion</li>
				    </ul>
				    <li>Verify 
				      <code>a.assertion.TAG_UAFV1_REG_ASSERTION.TAG_UAFV1_KRD.TAG_ATTESTATION_BASIC_FULL.Signature</code> 
				      using the attestation certificate (obtained before).</li>
				    <ul>
				      <li>If verification fails – continue with next assertion</li>
				    </ul>
				  </ol>
				</li>
				<li>If <code>Metadata(AAID).AttestationRootCertificates</code> for this AAID is
				  empty - continue with next assertion</li>
				<li>Mark assertion as positively verified</li>
            		      </ol>
			    </li>
			    <li>If <code>a.assertion.TAG_UAFV1_REG_ASSERTION.TAG_UAFV1_KRD</code> 
			      contains an object of type <code>TAG_ATTESTATION_BASIC_SURROGATE</code>
            		      <ol>
				<li>There is no real attestation for the AAID, so we just assume 
				  the AAID is the real one.</li>
				<li>If entry <code>AttestationRootCertificates</code> for the AAID in the
				  metadata is empty
				  <ul>
				    <li>Verify 
				      <code>a.assertion.TAG_UAFV1_REG_ASSERTION.TAG_ATTESTATION_BASIC_SURROGATE.Signature</code> 
				      using <code>a.assertion.TAG_UAFV1_REG_ASSERTION.TAG_UAFV1_KRD.TAG_PUB_KEY</code>
                    		      <ul>
					<li>If verification fails – continue with next assertion</li>
				      </ul>
				    </li>
				  </ul>
				</li>
				<li>If entry <code>AttestationRootCertificates</code> for the AAID in the
				  metadata is not empty - continue with next assertion 
				  (as the AAID obviously is expecting a different attestation method).</li>
				<li>Mark assertion as positively verified</li>
			      </ol>
			    </li>
			    <li>If <code>a.assertion.TAG_UAFV1_REG_ASSERTION.TAG_UAFV1_KRD</code> contains 
			      another <code>TAG_ATTESTATION</code> tag - verify the attestation by following
			      appropriate processing rules applicable to that attestation.
			      Currently this document only defines the processing rules for Basic Attestation.</li>
			  </ol>
			</li>
			<li>if <code>a.assertion.TAG_UAFV1_REG_ASSERTION</code> contains a different object than
			  <code>TAG_UAFV1_KRD</code> as first element, then follow the rules specific to that object.
			</li>
			<li>Extract <code>a.assertion.TAG_UAFV1_REG_ASSERTION.TAG_UAFV1_KRD.PublicKey</code> into PublicKey, 
			  <code>a.assertion.TAG_UAFV1_REG_ASSERTION.TAG_UAFV1_KRD.KeyID</code> into KeyID, 
			  <code>a.assertion.TAG_UAFV1_REG_ASSERTION.TAG_UAFV1_KRD.SignCounter</code> into SignCounter,
			  <code>a.assertion.TAG_UAFV1_REG_ASSERTION.TAG_UAFV1_KRD.TAG_ASSERTION_INFO.authenticatorVersion</code> 
			  into AuthenticatorVersion, 
			  <code>a.assertion.TAG_UAFV1_REG_ASSERTION.TAG_UAFV1_KRD.TAG_AAID</code> into AAID.
			</li>		  
		      </ol>
		    </li>
		    <li>if <code>a.assertion</code> doesn't contain an object of type <code>TAG_UAFV1_REG_ASSERTION</code>, 
		      then skip this assertion (as in this UAF v1 only <code>TAG_UAFV1_REG_ASSERTION</code> is defined).</li>
		  </ol>
		</li>
		<li>For each positively verified assertion <code>a</code>
		  <ul>
		    <li>Store PublicKey, KeyID, SignCounter, AuthenticatorVersion, AAID
		      and <code>a.tcDisplayPNGCharacteristics</code> into a record
		      associated with the user's identity . If an entry with the same
		      pair of AAID and KeyID already exists then fail (should never
		      occur).</li>
		  </ul>
		</li>
	      </ol>
	  </section>
	</section>
     </section>

     <section id="authentication-operation">

      <h3 aria-level="2" role="heading" id="h3_authentication-operation"><span class="secno">3.5 </span>Authentication Operation</h3>
      <div class="note"><div class="note-title" aria-level="3" role="heading" id="h_note_42"><span>Note</span></div><div class="">
	<figure id="fig-uaf-authentication-sequence-diagram">	  
          <img src="./img/fido-uaf-protocol-auth-sequence-diagram.png" onerror="./img/fido-uaf-protocol-auth-sequence-diagram.png" alt="UAF Authentication Sequence Diagram">
	  <figcaption>Fig. <span class="figno">8</span> <span class="fig-title">UAF Authentication Sequence Diagram</span></figcaption>
        </figure>
	
	<p>
	  During this operation, the FIDO Server asks the FIDO UAF Client to
	  authenticate user with server-specified authenticators, and return an
	  authentication response.</p>

	<p>In order for this operation to succeed,
	  the authenticator and the relying party must have a previously
	  shared registration.
	</p>
	
	<figure id="fig-uaf-authentication-cryptographic-data-flow">	  
          <img src="./img/fido-uaf-protocol-authn-sequence-high-level.png" onerror="./img/fido-uaf-protocol-authn-sequence-high-level.png" alt"uaf="" authentication="" cryptographic="" data="" flow"="">
	  <figcaption>Fig. <span class="figno">9</span> <span class="fig-title">UAF Authentication Cryptographic Data Flow</span></figcaption>
        </figure>
	<p>
	  Diagram of cryptographic flow:
	</p>
	<p>
	  The FIDO Server sends the <code>AppID</code> (see [<cite><a class="bibref" href="#bib-FIDOAppIDAndFacets">FIDOAppIDAndFacets</a></cite>]), the 
	  authenticator <a href="#policy-dictionary">policy</a>
          and the <a title="ServerChallenge" href="#idl-def-ServerChallenge" class="idlType"><code>ServerChallenge</code></a> to the FIDO UAF Client.
	  
	</p><p>
	  The FIDO UAF Client computes the hash of the
          <a title="FinalChallengeParams" href="#idl-def-FinalChallengeParams" class="idlType"><code>FinalChallengeParams</code></a>, produced
	  from the <a title="ServerChallenge" href="#idl-def-ServerChallenge" class="idlType"><code>ServerChallenge</code></a>
          and other values, as described in this document, and sends
	  the <code>AppID</code> and hashed <code>FinalChallengeParams</code> to the Authenticator.</p>

	<p>
	  The authenticator creates the <code>SignedData</code> object (see
	  <code>TAG_UAFV1_SIGNED_DATA</code> in [<cite><a class="bibref" href="#bib-UAFAuthnrCommands">UAFAuthnrCommands</a></cite>]) containing the hash of the final challenge parameters, and 
	  some other values and signs it using the <code>UAuth.priv</code> key. This assertion
	  is then cryptographically verified by the FIDO Server.</p>
      </div></div>
      
      <section id="transaction-dictionary">
	<h4 aria-level="3" role="heading" id="h4_transaction-dictionary"><span class="secno">3.5.1 </span>Transaction dictionary</h4>
	<p>Contains the Transaction Content provided by the FIDO Server:
	  
	  </p><pre class="idl"><span class="idlDictionary" id="idl-def-Transaction">dictionary <span class="idlDictionaryID">Transaction</span> {
<span class="idlMember">    <span class="idlMemberType">required DOMString</span>                  <span class="idlMemberName"><a href="#widl-Transaction-contentType">contentType</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">required DOMString</span>                  <span class="idlMemberName"><a href="#widl-Transaction-content">content</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">DisplayPNGCharacteristicsDescriptor</span> <span class="idlMemberName"><a href="#widl-Transaction-tcDisplayPNGCharacteristics">tcDisplayPNGCharacteristics</a></span>;</span>
};</span></pre><section id="dictionary-transaction-members"><h5 aria-level="4" role="heading" id="h5_dictionary-transaction-members"><span class="secno">3.5.1.1 </span>Dictionary <a class="idlType" href="#idl-def-Transaction"><code>Transaction</code></a> Members</h5><dl class="dictionary-members"><dt id="widl-Transaction-contentType"><code>contentType</code> of type <span class="idlMemberType">required DOMString</span></dt><dd>Contains the MIME Content-Type supported by the authenticator 
	      according its metadata statement (see [<cite><a class="bibref" href="#bib-UAFAuthnrMetadata">UAFAuthnrMetadata</a></cite>]).
	      <p>This version of the specification only supports the values 
		<code>text/plain</code> or <code>image/png</code>.
	    </p></dd><dt id="widl-Transaction-content"><code>content</code> of type <span class="idlMemberType">required DOMString</span></dt><dd><code>base64url(byte[1...])</code>
	      <p>Contains the base64-url encoded transaction content according 
		to the <code>contentType</code> to be shown to the user.
  	      </p><p>If <code>contentType</code> is "text/plain" then the content <em class="rfc2119" title="MUST">MUST</em> be the base64-url encoding of the ASCII
		encoded text with a maximum of 200 characters.
	    </p></dd><dt id="widl-Transaction-tcDisplayPNGCharacteristics"><code>tcDisplayPNGCharacteristics</code> of type <span class="idlMemberType">DisplayPNGCharacteristicsDescriptor</span></dt><dd>Transaction content PNG characteristics. For the definition of the
                DisplayPNGCharacteristicsDescriptor structure See [<cite><a class="bibref" href="#bib-UAFAuthnrMetadata">UAFAuthnrMetadata</a></cite>].
                This field <em class="rfc2119" title="MUST">MUST</em> be present if the contentType is "image/png".
            </dd></dl></section>

      </section>

      <section id="authentication-request-message">

          <h4 aria-level="3" role="heading" id="h4_authentication-request-message"><span class="secno">3.5.2 </span>Authentication Request Message</h4>
	  
          <p>
            UAF Authentication request message is represented as an array of dictionaries. 
	    Each dictionary contains an
            authentication request for a specific protocol version. The array <em class="rfc2119" title="MUST NOT">MUST NOT</em> 
	    contain two dictionaries of the
            same protocol version. For version "1.0" the request is defined as
            <a href="#idl-def-AuthenticationRequest">AuthenticationRequest</a> dictionary.
          </p>
	  
	  <div class="example"><div class="example-title"><span>Example 9</span>: UAF Authentication Request</div><pre class="example">[{
    "header": {
      "upv": {
        "major": 1,
        "minor": 0
      },
      "op": "Auth",
 "appID": "https://uaf-test-1.noknoktest.com:8443/SampleApp/uaf/facets",
      "serverData": "5s7n8-7_LDAtRIKKYqbAtTTOezVKCjl2mPorYzbpxRrZ-_3wWro
MXsF_pLYjNVm_l7bplAx4bkEwK6ibil9EHGfdfKOQ1q0tyEkNJFOgqdjVmLioroxgThlj8Is
tpt7q"
    },
    "challenge": "HQ1VkTUQC1NJDOo6OOWdxewrb9i5WthjfKIehFxpeuU",
    "policy": {
      "accepted": [
        [
          {
            "userVerification": 512,
            "keyProtection": 1,
            "tcDisplay": 1,
            "authenticationAlgorithms": [
              1
            ],
            "assertionSchemes": [
              "UAFV1TLV"
            ]
          }
        ],
        [
          {
            "userVerification": 4,
            "keyProtection": 1,
            "tcDisplay": 1,
            "authenticationAlgorithms": [
              1
            ],
            "assertionSchemes": [
              "UAFV1TLV"
            ]
          }
        ],
        [
          {
            "userVerification": 4,
            "keyProtection": 1,
            "tcDisplay": 1,
            "authenticationAlgorithms": [
              2
            ]
          }
        ],
        [
          {
            "userVerification": 2,
            "keyProtection": 4,
            "tcDisplay": 1,
            "authenticationAlgorithms": [
              2
            ]
          }
        ],
        [
          {
            "userVerification": 4,
            "keyProtection": 2,
            "tcDisplay": 1,
            "authenticationAlgorithms": [
              1,
              3
            ]
          }
        ],
        [
          {
            "userVerification": 2,
            "keyProtection": 2,
            "authenticationAlgorithms": [
              2
            ]
          }
        ],
        [
          {
            "userVerification": 32,
            "keyProtection": 2,
            "assertionSchemes": [
              "UAFV1TLV"
            ]
          },
          {
            "userVerification": 2,
            "authenticationAlgorithms": [
              1,
              3
            ],
            "assertionSchemes": [
              "UAFV1TLV"
            ]
          },
          {
            "userVerification": 2,
            "authenticationAlgorithms": [
              1,
              3
            ],
            "assertionSchemes": [
              "UAFV1TLV"
            ]
          },
          {
            "userVerification": 4,
            "keyProtection": 1,
            "authenticationAlgorithms": [
              1,
              3
            ],
            "assertionSchemes": [
              "UAFV1TLV"
            ]
          }
        ]
      ],
      "disallowed": [
        {
          "userVerification": 512,
          "keyProtection": 16,
          "assertionSchemes": [
            "UAFV1TLV"
          ]
        },
        {
          "userVerification": 256,
          "keyProtection": 16
        }
      ]
    }
}]</pre></div>


      </section>
      <section id="authenticationrequest-dictionary">
	<h4 aria-level="3" role="heading" id="h4_authenticationrequest-dictionary"><span class="secno">3.5.3 </span>AuthenticationRequest dictionary</h4>
	<p>Contains the UAF Authentication Request Message:
	  
	  </p><pre class="idl"><span class="idlDictionary" id="idl-def-AuthenticationRequest">dictionary <span class="idlDictionaryID">AuthenticationRequest</span> {
<span class="idlMember">    <span class="idlMemberType">required OperationHeader</span> <span class="idlMemberName"><a href="#widl-AuthenticationRequest-header">header</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">required ServerChallenge</span> <span class="idlMemberName"><a href="#widl-AuthenticationRequest-challenge">challenge</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType"><a href="#idl-def-Transaction" class="idlType"><code>Transaction</code></a>[]</span>            <span class="idlMemberName"><a href="#widl-AuthenticationRequest-transaction">transaction</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">required Policy</span>          <span class="idlMemberName"><a href="#widl-AuthenticationRequest-policy">policy</a></span>;</span>
};</span></pre><section id="dictionary-authenticationrequest-members"><h5 aria-level="4" role="heading" id="h5_dictionary-authenticationrequest-members"><span class="secno">3.5.3.1 </span>Dictionary <a class="idlType" href="#idl-def-AuthenticationRequest"><code>AuthenticationRequest</code></a> Members</h5><dl class="dictionary-members"><dt id="widl-AuthenticationRequest-header"><code>header</code> of type <span class="idlMemberType">required OperationHeader</span></dt><dd><code>Header.op</code> <em class="rfc2119" title="MUST">MUST</em> be "Auth"</dd><dt id="widl-AuthenticationRequest-challenge"><code>challenge</code> of type <span class="idlMemberType">required ServerChallenge</span></dt><dd>Server-provided challenge value</dd><dt id="widl-AuthenticationRequest-transaction"><code>transaction</code> of type array of <span class="idlMemberType"><a href="#idl-def-Transaction" class="idlType"><code>Transaction</code></a></span></dt><dd>Transaction data to be explicitly confirmed by the user.
              <p>The list contains the same transaction content in various 
		content types and various image sizes.
		Refer to [<cite><a class="bibref" href="#bib-UAFAuthnrMetadata">UAFAuthnrMetadata</a></cite>] for more information about
		Transaction Confirmation Display characteristics.</p>
	    </dd><dt id="widl-AuthenticationRequest-policy"><code>policy</code> of type <span class="idlMemberType">required Policy</span></dt><dd>Server-provided policy defining what types of authenticators are
	      acceptable for this authentication operation.</dd></dl></section>	
      </section>
      <section id="authenticatorsignassertion-dictionary">
	
	<h4 aria-level="3" role="heading" id="h4_authenticatorsignassertion-dictionary"><span class="secno">3.5.4 </span>AuthenticatorSignAssertion dictionary</h4>
	<p>Represents a response generated by a specific Authenticator:</p>
	  
	<pre class="idl"><span class="idlDictionary" id="idl-def-AuthenticatorSignAssertion">dictionary <span class="idlDictionaryID">AuthenticatorSignAssertion</span> {
<span class="idlMember">    <span class="idlMemberType">required DOMString</span> <span class="idlMemberName"><a href="#widl-AuthenticatorSignAssertion-assertionScheme">assertionScheme</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">required DOMString</span> <span class="idlMemberName"><a href="#widl-AuthenticatorSignAssertion-assertion">assertion</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType"><a href="#idl-def-Extension" class="idlType"><code>Extension</code></a>[]</span>        <span class="idlMemberName"><a href="#widl-AuthenticatorSignAssertion-exts">exts</a></span>;</span>
};</span></pre><section id="dictionary-authenticatorsignassertion-members"><h5 aria-level="4" role="heading" id="h5_dictionary-authenticatorsignassertion-members"><span class="secno">3.5.4.1 </span>Dictionary <a class="idlType" href="#idl-def-AuthenticatorSignAssertion"><code>AuthenticatorSignAssertion</code></a> Members</h5><dl class="dictionary-members"><dt id="widl-AuthenticatorSignAssertion-assertionScheme"><code>assertionScheme</code> of type <span class="idlMemberType">required DOMString</span></dt><dd>The name of the Assertion Scheme used to encode <code>assertion</code>.
	    See	<a href="#uaf-supported-assertion-schemes">UAF Supported Assertion Schemes</a> for details.
	    <div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_43"><span>Note</span></div><p class="">This assertionScheme is not part of a signed object and hence considered 
	      the <i>suspected</i> assertionScheme.</p></div>
	  </dd><dt id="widl-AuthenticatorSignAssertion-assertion"><code>assertion</code> of type <span class="idlMemberType">required DOMString</span></dt><dd><code>base64url(byte[1..4096])</code>
	    Contains the assertion containing a signature generated by <code>UAuth.priv</code>,
	    i.e. <code>TAG_UAFV1_AUTH_ASSERTION</code>.
	  </dd><dt id="widl-AuthenticatorSignAssertion-exts"><code>exts</code> of type array of <span class="idlMemberType"><a href="#idl-def-Extension" class="idlType"><code>Extension</code></a></span></dt><dd>Any extensions prepared by the Authenticator</dd></dl></section>
	
      </section>
      <section id="authenticationresponse-dictionary">
	<h4 aria-level="3" role="heading" id="h4_authenticationresponse-dictionary"><span class="secno">3.5.5 </span>AuthenticationResponse dictionary</h4>
	<p>Represents the response to a challenge, including the set of signed
          assertions from registered authenticators.
	  
	  </p><pre class="idl"><span class="idlDictionary" id="idl-def-AuthenticationResponse">dictionary <span class="idlDictionaryID">AuthenticationResponse</span> {
<span class="idlMember">    <span class="idlMemberType">required OperationHeader</span>              <span class="idlMemberName"><a href="#widl-AuthenticationResponse-header">header</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">required DOMString</span>                    <span class="idlMemberName"><a href="#widl-AuthenticationResponse-fcParams">fcParams</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">required AuthenticatorSignAssertion[]</span> <span class="idlMemberName"><a href="#widl-AuthenticationResponse-assertions">assertions</a></span>;</span>
};</span></pre><section id="dictionary-authenticationresponse-members"><h5 aria-level="4" role="heading" id="h5_dictionary-authenticationresponse-members"><span class="secno">3.5.5.1 </span>Dictionary <a class="idlType" href="#idl-def-AuthenticationResponse"><code>AuthenticationResponse</code></a> Members</h5><dl class="dictionary-members"><dt id="widl-AuthenticationResponse-header"><code>header</code> of type <span class="idlMemberType">required OperationHeader</span></dt><dd> <code>Header.op</code> <em class="rfc2119" title="MUST">MUST</em> be "Auth" </dd><dt id="widl-AuthenticationResponse-fcParams"><code>fcParams</code> of type <span class="idlMemberType">required DOMString</span></dt><dd>The field fcParams is the base64url-encoded serialized [<cite><a class="bibref" href="#bib-RFC4627">RFC4627</a></cite>]
	      FinalChallengeParams in UTF8 encoding 
	      (see <a href="#finalchallenge-dictionary">FinalChallengeParams dictionary</a>) 
	      which contains all parameters required
	      for the server to verify the Final Challenge.
	    </dd><dt id="widl-AuthenticationResponse-assertions"><code>assertions</code> of type array of <span class="idlMemberType">required AuthenticatorSignAssertion</span></dt><dd>The list of authenticator responses related to this operation.</dd></dl></section>
      </section>
      <section id="authentication-response-message">
	
	<h4 aria-level="3" role="heading" id="h4_authentication-response-message"><span class="secno">3.5.6 </span>Authentication Response Message</h4>

      <p>
        UAF Authentication response message is represented as an array of dictionaries. Each dictionary contains an
        authentication response for a specific protocol version. The array <em class="rfc2119" title="MUST NOT">MUST NOT</em> contain two dictionaries of the
        same protocol version. For version "1.0" the response is defined as
        <a href="#idl-def-AuthenticationResponse">AuthenticationResponse</a> dictionary.
      </p>



      <div class="example"><div class="example-title"><span>Example 10</span>: UAF Authentication Response</div><pre class="example">[{
    "assertions": [
      {
        "assertion": "Aj7WAAQ-jgALLgkAQUJDRCNBQkNEDi4FAAABAQEADy4gAHwyJA
EX8t1b2wOxbaKOC5ZL7ACqbLo_TtiQfK3DzDsHCi4gAFwCUz-dOuafXKXJLbkUrIzjAU6oDb
P8B9iLQRmCf58fEC4AAAkuIABkwI-f3bIe_Uin6IKIFvqLgAOrpk6_nr0oVAK9hIl82A0uBA
ACAAAABi5AADwDOcBvPslX2bRNy4SvFhAwhEAoBSGUitgMUNChgUSMxss3K3ukekq1paG7Fv
1v5mBmDCZVPt2NCTnjUxrjTp4",
        "assertionScheme": "UAFV1TLV"
      }
    ],
    "fcParams": "eyJhcHBJRCI6Imh0dHBzOi8vdWFmLXRlc3QtMS5ub2tub2t0ZXN0LmN
vbTo4NDQzL1NhbXBsZUFwcC91YWYvZmFjZXRzIiwiY2hhbGxlbmdlIjoiSFExVmtUVVFDMU5
KRE9vNk9PV2R4ZXdyYjlpNVd0aGpmS0llaEZ4cGV1VSIsImNoYW5uZWxCaW5kaW5nIjp7fSw
iZmFjZXRJRCI6ImNvbS5ub2tub2suYW5kcm9pZC5zYW1wbGVhcHAifQ",
    "header": {
 "appID": "https://uaf-test-1.noknoktest.com:8443/SampleApp/uaf/facets",
      "op": "Auth",
      "serverData": "5s7n8-7_LDAtRIKKYqbAtTTOezVKCjl2mPorYzbpxRrZ-_3wWro
MXsF_pLYjNVm_l7bplAx4bkEwK6ibil9EHGfdfKOQ1q0tyEkNJFOgqdjVmLioroxgThlj8Is
tpt7q",
      "upv": {
        "major": 1,
        "minor": 0
      }
    }
}]</pre></div>
      	<div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_44"><span>Note</span></div><p class="">Line breaks in fcParams have been inserted for improving readability.</p></div>
	
      </section>
      <section id="authentication-processing-rules">
	<h4 aria-level="3" role="heading" id="h4_authentication-processing-rules"><span class="secno">3.5.7 </span>Authentication Processing Rules</h4>
	
	<section id="authentication-request-generation-rules-for-fido-server"> 
	  <h5 aria-level="4" role="heading" id="h5_authentication-request-generation-rules-for-fido-server"><span class="secno">3.5.7.1 </span>Authentication Request Generation Rules for FIDO Server</h5>
	    <p>
	      The policy contains a 2-dimensional array of allowed
	      MatchCriteria (see <a href="#policy-dictionary">Policy</a>). This array can be
	      considered a list (first dimension) of sets (second dimension)
	      of authenticators (identified by MatchCriteria). All
	      authenticators in a specific set <em class="rfc2119" title="MUST">MUST</em> be used for authentication
	      simultaneously in order to match the policy. But any of those
	      sets in the list are valid, i.e. the list elements are
	      alternatives.</p>

	  <p>The FIDO Server <em class="rfc2119" title="MUST">MUST</em> follow the steps:</p>
	    <ol> 
	      <li>Construct appropriate authentication policy <code>p</code>
		<ol>
		  <li>for each set of alternative authenticators do
		    <ol>
		      <li>Create an 1-dimensional array of MatchCriteria objects v containing the set of authenticators 
			to be used for authentication simultaneously that need to be identified by <i>separate</i> MatchCriteria objects <code>m</code>.
			<ol> 
      			  <li>For each collection of authenticators <code>a</code> to be used for authentication
			    simultaneously that can be identified by the <i>same rule</i>, create a MatchCriteria object <code>m</code>, where
			    <ul>
      			      <li><code>m.aaid</code> <em class="rfc2119" title="MAY">MAY</em> be combined with (one or more of) <code>m.keyIDs</code>, 
				<code>m.attachmentHint</code>, <code>m.authenticatorVersion</code>, 
				and <code>m.exts</code>, but <code>m.aaid</code> <em class="rfc2119" title="MUST NOT">MUST NOT</em> be combined with 
				any other match criteria field.
			      </li>
      			      <li>If <code>m.aaid</code> is not provided - 
				at least <code>m.authenticationAlgorithms</code> and
				<code>m.assertionSchemes</code> <em class="rfc2119" title="MUST">MUST</em> be provided</li>
      			      <li>In case of step-up authentication (i.e. in the case where it is
				expected the user is already known due to a previous
				authentication step) every item in <code>Policy.accepted</code> <em class="rfc2119" title="MUST">MUST</em> include
				the <code>AAID</code> and <code>KeyID</code> of the authenticator registered for this
				account in order to avoid ambiguities when having multiple
				accounts at this relying party.</li>
			    </ul>
			  </li>
			  <li>Add <code>m</code> to <code>v</code>, e.g. <code>v[j+1]=m</code>.</li>
			</ol> 
		      </li>
		      <li>Add <code>v</code> to <code>p.allowed</code>, e.g. <code>p.allowed[i+1]=v</code></li>
		    </ol>
		  </li>
            <li>Create MatchCriteria objects <code>m[]</code> for all disallowed authenticators.
              <ol>
                <li>Create a MatchCriteria object <code>m</code> and add AAIDs of all disallowed authenticators
                  to <code>m.aaid</code>.
                  <p>The status (as provided in the metadata TOC [<cite><a class="bibref" href="#bib-UAFMetadataService">UAFMetadataService</a></cite>]) of
                    some authenticators might be unacceptable. Such authenticators <em class="rfc2119" title="SHOULD">SHOULD</em>
                    be included in <code>p.disallowed</code>. </p>
                </li>
                <li>If needed - create MatchCriteria <code>m</code> for other disallowed criteria
                  (e.g. unsupported authenticationAlgs)</li>
                <li>Add all <code>m</code> to <code>p.disallowed</code>.</li>
              </ol>
	    </li>
		</ol>
	      </li>
	      <li>Create an AuthenticationRequest object <code>r</code> with 
		appropriate <code>r.header</code> for each supported version, and
		<ol>
		  <li>FIDO Servers <em class="rfc2119" title="SHOULD NOT">SHOULD NOT</em> assume any implicit integrity protection 
		    of <code>r.header.serverData</code>.
		    FIDO Servers that depend on the integrity of <code>r.header.serverData</code> <em class="rfc2119" title="SHOULD">SHOULD</em>
		    apply and verify a cryptographically secure Message
		    Authentication Code (MAC) to serverData and they <em class="rfc2119" title="SHOULD">SHOULD</em> also cryptographically bind serverData to 
		    the related message, e.g. by re-including <code>r.challenge</code>, see also section
		    <a href="#serverdata-and-keyhandle">ServerData and KeyHandle</a>.
		    <div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_45"><span>Note</span></div><p class="">All other FIDO components (except the FIDO server) will treat
		      <code>r.header.serverData</code> as an opaque value.  As a consequence
		      the FIDO server can implement any suitable cryptographic protection method.</p></div>
		  </li>
		  <li>Generate a random challenge and assign it to <code>r.challenge</code></li>
		  <li>If this is a transaction confirmation operation - look up 
		    TransactionConfirmationDisplayContentTypes/
		    TransactionConfirmationDisplayPNGCharacteristics from authenticator metadata of every
		    participating AAID, generate a list of corresponding transaction content and
		    insert the list into <code>r.transaction</code>.
		    <ul>
		      <li>
			If the authenticator reported (a dynamic) 
			<code>AuthenticatorRegistrationAssertion.tcDisplayPNGCharacteristics</code> during
			Registration - it <em class="rfc2119" title="MUST">MUST</em> be preferred over the (static) value specified in 
			the authenticator Metadata.
		      </li>
		    </ul>
		  </li>
		  <li>Set <code>r.policy</code> to our new policy object <code>p</code> created above, 
		    e.g. <code>r.policy = p</code>.
		  </li>
		  <li>Add the authentication request message the array</li>		  
		</ol>
	      </li>
	      <li>Send the array of authentication request messages to the FIDO UAF Client</li>
	    </ol>
	</section>

	<section id="authentication-request-processing-rules-for-fido-uaf-client">
	  <h5 aria-level="4" role="heading" id="h5_authentication-request-processing-rules-for-fido-uaf-client"><span class="secno">3.5.7.2 </span>Authentication Request Processing Rules for FIDO UAF Client</h5>
	  <p>The FIDO UAF Client <em class="rfc2119" title="MUST">MUST</em> follow the steps:
	    </p><ol> 
	      <li>Choose the message with major version <code>1</code> and minor version <code>0</code></li>
	      <li>Parse the message <code>m</code>
		<ul>
      		  <li>If a mandatory field in the UAF message is not present or a
		    field doesn't correspond to its type and value then reject the
		    operation</li>
		</ul>
		</li>
	      <li>Obtain <code>FacetID</code> of the requesting Application. If the <code>AppID</code> is missing or 
		empty, set the <code>AppID</code> to the <code>FacetID</code>.
		<p>Verify that the <code>FacetID</code> is authorized for the <code>AppID</code> according 
		  to the algorithms in [<cite><a class="bibref" href="#bib-FIDOAppIDAndFacets">FIDOAppIDAndFacets</a></cite>].</p>
  		<ul> 
		  <li>If the <code>FacetID</code> of the requesting Application is not authorized, reject the operation</li>
		</ul> 
	      </li>	      
	      <li>Filter available authenticators with the given policy and
		present the filtered list to User.
		<ul>
		  <li>If <code>AuthenticationRequest.policy.accepted</code> list is empty then suggest any
                    registered authenticator to the user for authentication</li>
		  
		</ul>
	      </li>
	      <li>Let the user select the preferred Authenticator.</li>
	      <li>Obtain TLS data if its available</li>
	      <li>Create a FinalChallengeParams structure <code>fcp</code> and set <code>fcp.AppID</code>,
		<code>fcp.challenge</code>, <code>fcp.facetID</code>, and <code>fcp.channelBinding</code> appropriately.
		Serialize [<cite><a class="bibref" href="#bib-RFC4627">RFC4627</a></cite>] <code>fcp</code> using UTF8 encoding and base64url
		encode it.
		<ul> 
		  <li><code>FinalChallenge = base64url(serialize(utf8encode(fcp)))</code></li>
		</ul>
	      </li>
	      <li>For each authenticator that supports an Authenticator Interface
		Version AIV compatible with message version
		<code>AuthenticationRequest.header.upv</code> (see <a href="#version-negotiation">Version Negotiation</a>) and
		user agrees to authenticate with:
		<ol>
		  <li>Add <code>AppID</code>, <code>FinalChallenge</code>, <code>Transactions</code> (if present),
		    and all other fields to the ASMRequest.</li>
		  <li>Send the ASMRequest to the ASM.</li>
		</ol>
	      </li>
	    </ol> 
	</section>
     <section id="authentication-request-processing-rules-for-fido-authenticator">
      <h5 aria-level="4" role="heading" id="h5_authentication-request-processing-rules-for-fido-authenticator"><span class="secno">3.5.7.3 </span>Authentication Request Processing Rules for FIDO Authenticator</h5>
      
      <p>See [<cite><a class="bibref" href="#bib-UAFAuthnrCommands">UAFAuthnrCommands</a></cite>], section "Sign Command".
     
     </p></section>
     <section id="authentication-response-generation-rules-for-fido-uaf-client"> 
       <h5 aria-level="4" role="heading" id="h5_authentication-response-generation-rules-for-fido-uaf-client"><span class="secno">3.5.7.4 </span>Authentication Response Generation Rules for FIDO UAF Client</h5>
       <p>The FIDO UAF Client <em class="rfc2119" title="MUST">MUST</em> follow the steps:
	 </p><ol>
	   <li>Create an AuthenticationResponse message</li>
	   <li>Copy <code>AuthenticationRequest.header</code> into <code>AuthenticationResponse.header</code></li>
	   <li>Fill out <code>AuthenticationResponse.FinalChallengeParams</code> with appropriate
	     fields and then stringify it</li>
	   <li>Append the response from each authenticator into <code>AuthenticationResponse.assertions</code></li>
	   <li>Send AuthenticationResponse message to the FIDO Server</li>
	 </ol> 
     </section>

     <section id="authentication-response-processing-rules-for-fido-server">
       <h5 aria-level="4" role="heading" id="h5_authentication-response-processing-rules-for-fido-server"><span class="secno">3.5.7.5 </span>Authentication Response Processing Rules for FIDO Server</h5>

         <div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_46"><span>Note</span></div><p class="">
             The following processing rules assume that authenticator supports "UAFV1TLV" assertion scheme.
             Currently "UAFV1TLV" is the only defined and supported assertion scheme. When a new 
	     assertion scheme is added to UAF protocol - this section will be extended 
	     with corresponding processing rules.
         </p></div>

       <p>The FIDO Server <em class="rfc2119" title="MUST">MUST</em> follow the steps:</p>
	 <ol> 
	   <li>Parse the message
      	     <ol>
      	       <li>If protocol version (<code>AuthenticationResponse.header.upv</code>) is not 
		 supported – reject the operation</li>
      	       <li>If a mandatory field in UAF message is not present or a field
		 doesn't correspond to its type and value - reject the operation</li>
	     </ol>
	   </li>
	   <li>Verify that <code>AuthenticationResponse.header.serverData</code>, if used, passes any
	     implementation-specific checks against its validity.  See also section
	     <a href="#serverdata-and-keyhandle">ServerData and KeyHandle</a>.
	   </li>
	   <li>base64url decode <code>AuthenticationResponse.fcParams</code> and convert into an
	     object (<code>fcp</code>)</li>
	   <li>Verify each field in fcp and make sure it's valid:
     	     <ol> 
      	       <li>Make sure <code>AppID</code> corresponds to the one stored by the FIDO Server</li>
      	       <li>Make sure <code>FacetID</code> is in the list of trusted FacetIDs [<cite><a class="bibref" href="#bib-FIDOAppIDAndFacets">FIDOAppIDAndFacets</a></cite>]</li>
      	       <li>Make sure <code>ChannelBinding</code> is as expected (see 
		 section <a href="#channelbinding-dictionary">ChannelBinding dictionary</a>)</li>
               <li>Verify that the <code>ServerChallenge</code>
		 submitted by the client has been generated by the FIDO
		 server
	       </li>
      	       <li>Reject the response if any of the above checks fails</li>
             </ol> 
	   </li>
	   <li>For each assertion <code>a</code> in <code>AuthenticationResponse.assertions</code>
	     <ol>
      	      <li>Parse TLV data from <code>a.assertion</code> assuming it is encoded according to 
		the suspected assertion scheme <code>a.assertionScheme</code> and make sure it 
		contains all mandatory fields (indicated in authenticator Metadata) it is supposed to
		have and has a valid syntax.
		<ul> 
		  <li>If it doesn't - continue with next assertion</li>
		</ul>
	      </li>
	      <li>Retrieve the AAID from the assertion. 
		<div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_47"><span>Note</span></div><p class="">The AAID in <code>TAG_UAFV1_SIGNED_DATA</code> is contained 
		  in <code>a.assertion.TAG_UAFV1_AUTH_ASSERTION.TAG_UAFV1_SIGNED_DATA.TAG_AAID</code>.</p></div>
	      </li>
	      <li>Verify that <code>a.assertionScheme</code> matches <code>Metadata(AAID).assertionScheme</code>
		<ul> 
		  <li>If it doesn't match - continue with next assertion</li>
		</ul>
	      </li>

      	       <li>Make sure that the AAID indeed matches the policy of the Authentication Request
     		 <ul> 
      		   <li> If it doesn't meet the policy – continue with next assertion</li>
		 </ul>
	       </li>
	       <li>if <code>a.assertion</code> contains an object of type <code>TAG_UAFV1_AUTH_ASSERTION</code>, then 
		 <ol>
		   <li>if <code>a.assertion.TAG_UAFV1_AUTH_ASSERTION</code> contains <code>TAG_UAFV1_SIGNED_DATA</code> as first element: 
		     <ol>	       
		       <li>Obtain <code>Metadata(AAID).AuthenticatorVersion</code> for this AAID and make sure that
			 it is lower or equal to 
			 <code>a.assertion.TAG_UAFV1_AUTH_ASSERTION.TAG_UAFV1_SIGNED_DATA.TAG_ASSERTION_INFO.AuthenticatorVersion</code>.
			 <ul>
			  <li>If <code>Metadata(AAID).AuthenticatorVersion</code> is higher (i.e. the 
			    authenticator firmware is outdated), 
			    it is <em class="rfc2119" title="RECOMMENDED">RECOMMENDED</em> to assume increased authentication risk.
			    See "StatusReport dictionary" and "Metadata TOC object Processing Rules" 
			    in [<cite><a class="bibref" href="#bib-UAFMetadataService">UAFMetadataService</a></cite>] for more details on this.
			  </li>
			 </ul>
		       </li>
		       <li>Retrieve 
			 <code>a.assertion.TAG_UAFV1_AUTH_ASSERTION.TAG_UAFV1_SIGNED_DATA.TAG_KEYID</code> as KeyID
		       </li>
		       <li>Locate <code>UAuth.pub</code> public key associated 
			 with (AAID, KeyID) in the user's record.
			 <ul>
			   <li>If such record doesn't exist - continue with next assertion</li>
			 </ul>
		       </li>
      		       <li>Verify the AAID against the AAID stored
			 in the user's record at time of Registration.
      			 <ul>		   
			   <li>If comparison fails – continue with next assertion</li>
			 </ul>
		       </li>
		       <li>Locate authenticator specific authentication algorithms from
			 authenticator metadata (field <code>AuthenticationAlgs</code>)</li>
		       
		       <li>Check the Signature Counter 
			 <code>a.assertion.TAG_UAFV1_AUTH_ASSERTION.TAG_UAFV1_SIGNED_DATA.SignCounter</code> 
			 and make sure it is either not supported by the authenticator 
			 (i.e. the value provided and the value stored in the user's record are both 0) 
			 or it has been incremented (compared to the value stored in the user's record)
			 <ul>
      			   <li>If it is greater than 0, but didn't increment - continue with next assertion 
			     (as this is a cloned authenticator or a cloned authenticator 
			     has been used previously).</li>
     			 </ul> 
		       </li>
      		       <li>Hash <code>AuthenticationResponse.FinalChallengeParams</code> using the hashing
			 algorithm suitable for this authenticator type. Look up the
			 hash algorithm in authenticator Metadata, field
			 <code>AuthenticationAlgs</code>. It is the hash algorithm associated with
			 the first entry related to a constant with prefix UAF_ALG_SIGN.
      			 <ul>
			   <li><code>FCHash = hash(AuthenticationResponse.FinalChallengeParams)</code></li>
			 </ul>
		       </li>
      		       <li>Make sure that 
			 <code>a.assertion.TAG_UAFV1_AUTH_ASSERTION.TAG_UAFV1_SIGNED_DATA.TAG_FINAL_CHALLENGE</code>
			 == <code>FCHash</code></li>
      		       <ul>
			 <li>If comparison fails – continue with next assertion</li>
     		       </ul> 
      		       <li>If 
			 <code>a.assertion.TAG_UAFV1_AUTH_ASSERTION.TAG_UAFV1_SIGNED_DATA.TAG_ASSERTION_INFO.authenticationMode</code>
			 == <code>2</code>
			 <div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_48"><span>Note</span></div><p class="">The transaction hash included in this <code>AuthenticationResponse</code> 
			   must match the transaction content specified in the related <code>AuthenticationRequest</code>.
			   As FIDO doesn’t mandate any specific FIDO Server API, the transaction content could be cached 
			   by any relying party software component, e.g. the FIDO Server or the relying party Web Application.</p></div>
     			 <ol> 
      			   <li>Make sure there is a transaction cached on Relying Party side.
			     <ul>
      			       <li>If not – continue with next assertion</li>
			     </ul>
			   </li>
      			   <li>Go over all cached forms of the transaction content (potentially multiple cached PNGs for
			     the same transaction) and calculate their hashes using hashing algorithm suitable for
			     this authenticator (same hash algorithm as used for FinalChallenge).
			     <ul>
			       <li>For each <code>cachedTransaction</code> add <code>hash(cachedTransaction)</code> into
				 <code>cachedTransactionHashList</code>
			       </li>
			     </ul>
			   </li>
      			   <li>Make sure that <code>a.TransactionHash</code> is in <code>cachedTransactionHashList</code>
     			     <ul> 
			       <li>If it's not in the list – continue with next assertion</li>
			     </ul>
			   </li>
			 </ol>
		       </li>
      		       <li>Use <code>UAuth.pub</code> key and appropriate authentication algorithm to
			 verify <code>a.assertion.TAG_UAFV1_AUTH_ASSERTION.TAG_SIGNATURE</code>
      			 <ol>
			   <li>If signature verification fails – continue with next assertion</li>
			   <li>Update <code>SignCounter</code> in user's record with 
			     <code>a.assertion.TAG_UAFV1_AUTH_ASSERTION.TAG_UAFV1_SIGNED_DATA.SignCounter</code></li>
			 </ol>
		       </li>
		     </ol>
		   </li>
		   <li>if <code>a.assertion.TAG_UAFV1_AUTH_ASSERTION</code> contains a different object than 
		     <code>TAG_UAFV1_SIGNED_DATA</code> as first element, 
		     then follow the rules specific to that object.</li>
		 </ol>
	       </li>
	       <li>if <code>a.assertion</code> doesn't contain an object of type <code>TAG_UAFV1_AUTH_ASSERTION</code>, 
		 then skip this assertion (as in this UAF v1 only <code>TAG_UAFV1_AUTH_ASSERTION</code> is defined).</li>
	       <li>Treat this assertion <code>a</code> as positively verified.</li>
	     </ol>
	   </li>
	   <li>Process all positively verified authentication assertions <code>a</code>.</li>
	 </ol>
     </section>
      </section>
     </section>
     
     <section id="deregistration-operation"> 
       <h3 aria-level="2" role="heading" id="h3_deregistration-operation"><span class="secno">3.6 </span>Deregistration Operation</h3>
       
       <p>
	 This operation allows FIDO Server to ask the FIDO Authenticator
	 to delete keys related to the particular relying party. </p>
       <div class="note"><div class="note-title" aria-level="3" role="heading" id="h_note_49"><span>Note</span></div><p class="">The
	 Along with other cases FIDO Server should also trigger this operation when the user removes
	 his account at the relying party.</p></div>
       <section id="deregistration-request-message">	
	 <h4 aria-level="3" role="heading" id="h4_deregistration-request-message"><span class="secno">3.6.1 </span>Deregistration Request Message</h4>
	 
	 <p>
           The FIDO UAF Deregistration request message is represented as an array of dictionaries. Each dictionary contains a
           deregistration request for a specific protocol version. The array <em class="rfc2119" title="MUST NOT">MUST NOT</em> contain two dictionaries of the
           same protocol version. For version "1.0" the request is defined as
           <a href="#idl-def-DeregistrationRequest">DeregistrationRequest</a> dictionary.
	 </p>
      
      <div class="example"><div class="example-title"><span>Example 11</span>: UAF Deregistration Request</div><pre class="example">[{
    "header": {
      "op": "Dereg",
      "upv": {
        "major": 1,
        "minor": 0
      },
  "appID": "https://uaf-test-1.noknoktest.com:8443/SampleApp/uaf/facets"
    },
    "authenticators": [
      {
        "aaid": "ABCD#ABCD",
        "keyID": "ZMCPn92yHv1Ip-iCiBb6i4ADq6ZOv569KFQCvYSJfNg"
      }
    ]
}]</pre></div>
	 <div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_50"><span>Note</span></div><p class="">There is no deregistration response object.</p></div>
       </section>
       
       
       <section id="deregisterauthenticator-dictionary">
	 <h4 aria-level="3" role="heading" id="h4_deregisterauthenticator-dictionary"><span class="secno">3.6.2 </span>DeregisterAuthenticator dictionary</h4>
	 
	 <pre class="idl"><span class="idlDictionary" id="idl-def-DeregisterAuthenticator">dictionary <span class="idlDictionaryID">DeregisterAuthenticator</span> {
<span class="idlMember">    <span class="idlMemberType">required AAID</span>  <span class="idlMemberName"><a href="#widl-DeregisterAuthenticator-aaid">aaid</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">required KeyID</span> <span class="idlMemberName"><a href="#widl-DeregisterAuthenticator-keyID">keyID</a></span>;</span>
};</span></pre><section id="dictionary-deregisterauthenticator-members"><h5 aria-level="4" role="heading" id="h5_dictionary-deregisterauthenticator-members"><span class="secno">3.6.2.1 </span>Dictionary <a class="idlType" href="#idl-def-DeregisterAuthenticator"><code>DeregisterAuthenticator</code></a> Members</h5><dl class="dictionary-members"><dt id="widl-DeregisterAuthenticator-aaid"><code>aaid</code> of type <span class="idlMemberType">required AAID</span></dt><dd>AAID of the authenticator to deregister.</dd><dt id="widl-DeregisterAuthenticator-keyID"><code>keyID</code> of type <span class="idlMemberType">required KeyID</span></dt><dd>The unique KeyID related to <code>UAuth.priv</code>.
	     KeyID is assumed to be unique within the scope of an AAID only.
	   </dd></dl></section>	
       </section>
       
       <section id="deregistrationrequest-dictionary">
         <h4 aria-level="3" role="heading" id="h4_deregistrationrequest-dictionary"><span class="secno">3.6.3 </span>DeregistrationRequest dictionary</h4>
	 <pre class="idl"><span class="idlDictionary" id="idl-def-DeregistrationRequest">dictionary <span class="idlDictionaryID">DeregistrationRequest</span> {
<span class="idlMember">    <span class="idlMemberType">required OperationHeader</span>           <span class="idlMemberName"><a href="#widl-DeregistrationRequest-header">header</a></span>;</span>
<span class="idlMember">    <span class="idlMemberType">required DeregisterAuthenticator[]</span> <span class="idlMemberName"><a href="#widl-DeregistrationRequest-authenticators">authenticators</a></span>;</span>
};</span></pre><section id="dictionary-deregistrationrequest-members"><h5 aria-level="4" role="heading" id="h5_dictionary-deregistrationrequest-members"><span class="secno">3.6.3.1 </span>Dictionary <a class="idlType" href="#idl-def-DeregistrationRequest"><code>DeregistrationRequest</code></a> Members</h5><dl class="dictionary-members"><dt id="widl-DeregistrationRequest-header"><code>header</code> of type <span class="idlMemberType">required OperationHeader</span></dt><dd> <code>Header.op</code> <em class="rfc2119" title="MUST">MUST</em> be "Dereg".
	     
	   </dd><dt id="widl-DeregistrationRequest-authenticators"><code>authenticators</code> of type array of <span class="idlMemberType">required DeregisterAuthenticator</span></dt><dd>List of authenticators to be deregistered.</dd></dl></section>
       </section>
       <section id="deregistration-processing-rules">
	 <h4 aria-level="3" role="heading" id="h4_deregistration-processing-rules"><span class="secno">3.6.4 </span>Deregistration Processing Rules</h4> 
	 
	 <section id="deregistration-request-generation-rules-for-fido-server">
	   <h5 aria-level="4" role="heading" id="h5_deregistration-request-generation-rules-for-fido-server"><span class="secno">3.6.4.1 </span>Deregistration Request Generation Rules for FIDO Server</h5>
	   <p>The FIDO Server <em class="rfc2119" title="MUST">MUST</em> follow the steps:</p>
     	   <ol> 
      	     <li>Create a deregistration request message <code>m</code> with major version of
	       <code>m.header.upv</code> set to <code>1</code> and minor 
	       version set to <code>0</code></li>
      	     <li>For each authenticator to be deregistered
      	       <ol>
		 <li>Create DeregisterAuthenticator object 
		   <code>o</code> for authenticator to be deregistered</li>
      		 <li>Set <code>o.aaid</code> and <code>o.keyID</code> appropriately</li>
      		 <li>Append <code>o</code> the <code>m.authenticators</code></li>
      		 <li>delete related entry in FIDO Server's account database</li>
     	       </ol> 
	     </li>
      	     <li>Send message to FIDO UAF Client</li>
	   </ol>
	 </section>
	 
	 <section id="deregistration-request-processing-rules-for-fido-uaf-client"> 
	   <h5 aria-level="4" role="heading" id="h5_deregistration-request-processing-rules-for-fido-uaf-client"><span class="secno">3.6.4.2 </span>Deregistration Request Processing Rules for FIDO UAF Client</h5>

	   <p>The FIDO UAF Client <em class="rfc2119" title="MUST">MUST</em> follow the steps:</p>
     	   <ol> 
      	     <li>Choose the message with major version <code>1</code> and minor version <code>0</code></li>
      	     <li>Parse the message
      	       <ul>
      		 <li>If a mandatory field in <code>DeregistrationRequest</code> message is not present
		   or a field doesn't correspond to its type and value – reject
		   the operation</li>
     	       </ul> 
	     </li>
      	     <li>For each authenticator compatible with the message version
	       <code>DeregistrationRequest.header.upv</code> and has an AAID equal to one of the provideded <code>AAID</code>s:
      	       <ol>
      		 <li>Create appropriate <code>ASMRequest</code> for Deregister function and send it to the Authenticator
	       </li></ol>
	     </li>
	   </ol>
	 </section>
	 <section id="deregistration-request-processing-rules-for-fido-authenticator">
      	   <h5 aria-level="4" role="heading" id="h5_deregistration-request-processing-rules-for-fido-authenticator"><span class="secno">3.6.4.3 </span>Deregistration Request Processing Rules for FIDO Authenticator</h5>
	   
      	   <p>See [<cite><a class="bibref" href="#bib-UAFASM">UAFASM</a></cite>] section "Deregister request".</p>
	 </section>
       </section>
     </section>
    </section>
    <section class="informative" id="considerations">
      <!--OddPage--><h2 aria-level="1" role="heading" id="h2_considerations"><span class="secno">4. </span>Considerations</h2><p><em>This section is non-normative.</em></p>
      
      <section id="protocol-core-design-considerations">
	<h3 aria-level="2" role="heading" id="h3_protocol-core-design-considerations"><span class="secno">4.1 </span>Protocol Core Design Considerations</h3>
	
	<p>
	  This section describes the important design elements used in the
	  protocol.</p>
	
	<section id="authenticator-metadata"> 
	  <h4 aria-level="3" role="heading" id="h4_authenticator-metadata"><span class="secno">4.1.1 </span>Authenticator Metadata</h4>
	  
	  <p>
	    It is assumed that FIDO Server has access to a list of all
	    supported authenticators and their corresponding Metadata.
	    authenticator metadata [UAFAuthnrMetadata] contains
	    information such as:</p>
	  <ul> 
	    <li>Supported Registration and Authentication Schemes</li>
	    <li>Authentication Factor, Installation type, supported
	      content-types and other supplementary information, etc.</li>
	  </ul>
	  
	  <p>
	    In order to make a decision about which authenticators are
	    appropriate for a specific transaction, FIDO Server looks up
	    the list of authenticator metadata by AAID and retrieves the
	    required information from it.</p>
	  
	  <p class="normative">
	    Each entry in the authenticator metadata repository <em class="rfc2119" title="MUST">MUST</em> be
	    identified with a unique authenticator Attestation ID (AAID).</p>
	</section>
	
	<section id="authenticator-attestation"> 
	  <h4 aria-level="3" role="heading" id="h4_authenticator-attestation"><span class="secno">4.1.2 </span>Authenticator Attestation</h4>
	  
	  <p>
	    Authenticator Attestation is the process of validating
	    authenticator model identity during registration. It allows
	    Relying Parties to cryptographically verify that the
	    authenticator reported by FIDO UAF Client is really what it claims
	    to be.</p>
	    
	  <p>
	    Using authenticator Attestation, a relying party
	    "example-rp.com" will be able to verify that the
	    authenticator model of the "example-Authenticator", reported
	    with AAID "1234#5678", is not malware running on the FIDO User
	    Device but is really a authenticator of model "1234#5678".</p>
      
	  <p class="normative">
	    FIDO Authenticators <em class="rfc2119" title="SHOULD">SHOULD</em> support "Basic Attestation" described
	    below. New Attestation mechanisms may be added to the protocol
	    over time.</p>
      
	  <p class="normative">
	    FIDO Authenticators not providing sufficient protection for
	    Attestation keys (non-attested authenticators) <em class="rfc2119" title="MUST">MUST</em> use the
	    UAuth.priv key in order to formally generate the same KeyRegistrationData object 
	    as attested authenticators. This behavior <em class="rfc2119" title="MUST">MUST</em> be properly declared in the Authenticator
	    Metadata.</p>

	  <section id="basic-attestation">      
	    <h5 aria-level="4" role="heading" id="h5_basic-attestation"><span class="secno">4.1.2.1 </span>Basic Attestation</h5>
	    
	    <div class="normative">
	      There are two different flavors of Basic Attestation:
	      <dl>
		<dt>Full Basic Attestation</dt>
		<dd>Based on an attestation private key shared among a class of authenticators (e.g. same model).</dd>
		<dt>Surrogate Basic Attestation</dt>
		<dd>Just syntactically a Basic Attestation.  The attestation object self-signed, i.e. it 
		  is signed using the UAuth.priv key, i.e. the key corresponding to 
		  the UAuth.pub key included in the attestation object.
		  As a consequence it <strong>does not</strong> provide a cryptographic 
		  proof of the security characteristics. But it is the best thing 
		  we can do if the authenticator is not able to have an attestation private key.
		</dd>
	      </dl>
	    </div>

	    <section id="full-basic-attestation"> 
	      <h6 aria-level="5" role="heading" id="h6_full-basic-attestation"><span class="secno">4.1.2.1.1 </span>Full Basic Attestation</h6>
	      
	      <div class="note"><div class="note-title" aria-level="6" role="heading" id="h_note_51"><span>Note</span></div><p class="certification">
		FIDO Servers must have access to a trust anchor for verifying
		attestation public keys (i.e. Attestation Certificate trust
		store) in order to follow the assumptions made in [<cite><a class="bibref" href="#bib-FIDOSecRef">FIDOSecRef</a></cite>]. 
		Authenticators must provide its attestation
		signature during the registration process for the same reason. 
		The attestation trust anchor is shared with FIDO Servers out of band (as part
		of the Metadata). This sharing process shouldt be done according 
		to [<cite><a class="bibref" href="#bib-UAFMetadataService">UAFMetadataService</a></cite>].</p></div>
	      
	      <div class="note"><div class="note-title" aria-level="6" role="heading" id="h_note_52"><span>Note</span></div><p class="">
		The protection measures of the Authenticator's attestation
		private key depend on the specific authenticator model's
		implementation.</p></div>
	      
	      <div class="note"><div class="note-title" aria-level="6" role="heading" id="h_note_53"><span>Note</span></div><p class="certification specific">
		The FIDO Server must load the appropriate Authenticator
		Attestation Root Certificate from its trust store based on the
		AAID provided in KeyRegistrationData object.</p></div>

	      <p>
		In this Full Basic Attestation model, a large number of
		authenticators must share the same Attestation certificate and
		Attestation Private Key in order to provide non-linkability
		(see <a href="#protocol-core-design-considerations">Protocol Core Design Considerations</a>).
		Authenticators can only be identified on a production batch
		level or an AAID level by their Attestation Certificate, and
		not individually. A large number of authenticators sharing the
		same Attestation Certificate provides better privacy, but also
		makes the related private key a more attractive attack target.</p>
	 
	      <div class="note"><div class="note-title" aria-level="6" role="heading" id="h_note_54"><span>Note</span></div><p class="certification specific">
		A given set of authenticators sharing the same manufacturer and
		essential characteristics must not be issued a new Attestation
		Key before at least 100,000 devices are issued the previous
		shared key.</p></div>      
	 
	      <figure id="fig-attestation-certificate-chain">	  
		<img src="./img/fido-uaf-protocol-attestation-cert-chain.png" onerror="./img/fido-uaf-protocol-attestation-cert-chain.png" alt="Attestation Certificate Chain">
		<figcaption>Fig. <span class="figno">10</span> <span class="fig-title">Attestation Certificate Chain</span></figcaption>
              </figure>
	    </section>
	    <section id="surrogate-basic-attestation">
	      <h6 aria-level="5" role="heading" id="h6_surrogate-basic-attestation"><span class="secno">4.1.2.1.2 </span>Surrogate Basic Attestation</h6>
	      
              <p class="normative">
		In this attestation method, the UAuth.priv key <em class="rfc2119" title="MUST">MUST</em> be used to sign the
  		Registration Data object. This behavior <em class="rfc2119" title="MUST">MUST</em> be properly declared in the Authenticator
		Metadata.</p>
		
              <div class="note"><div class="note-title" aria-level="6" role="heading" id="h_note_55"><span>Note</span></div><p class="certification">
		FIDO Authenticators not providing sufficient protection for
		Attestation keys (non-attested authenticators) must use this attestation method.</p></div>		
	    </section>
	  </section>
	</section>
	<section id="error-handling"> 
	  <h4 aria-level="3" role="heading" id="h4_error-handling"><span class="secno">4.1.3 </span>Error Handling</h4>
	  
	  <div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_56"><span>Note</span></div><p class="certificaion specific">
	    FIDO Servers must inform the calling Relying Party Web
	    Application Server (see <a href="#FIDOInteroperabilityOverview" class="fig-ref">FIDO Interoperability
	      Overview</a>) about any error conditions encountered when
	    generating or processing UAF messages through their proprietary
	    API.</p></div>
      
	  <p class="normative">
	    FIDO Authenticators <em class="rfc2119" title="MUST">MUST</em> inform the FIDO UAF Client (see <a href="#FIDOInteroperabilityOverview" class="fig-ref">FIDO Interoperability
	      Overview</a>) about any error conditions
	    encountered when processing commands through the Authenticator
	    Specific Module (ASM). See [<cite><a class="bibref" href="#bib-UAFASM">UAFASM</a></cite>] and [<cite><a class="bibref" href="#bib-UAFAuthnrCommands">UAFAuthnrCommands</a></cite>] for
	    details.</p>
	</section>
	<section id="assertion-schemes"> 
	  <h4 aria-level="3" role="heading" id="h4_assertion-schemes"><span class="secno">4.1.4 </span>Assertion Schemes</h4>
	  
	  <p>
	    UAF Protocol is designed to be compatible with a variety of
	    existing authenticators (TPMs, Fingerprint Sensors, Secure
	    Elements, etc.) and also future authenticators designed for
	    FIDO. Therefore extensibility is a core capability designed
	    into the protocol.</p>
	  
	  <p>
	    It is considered that there are two particular aspects that need
	    careful extensibility. These are:</p>
	  <ul> 
      	    <li>Cryptographic key provisioning (KeyRegistrationData)</li>
            <li>Cryptographic authentication and signature (SignedData)</li>
	  </ul>
	  
	  <p>
	    The combination of KeyRegistrationData and SignedData schemes is
	    called an Assertion Scheme.</p>
      
	  <p>
	    The UAF protocol allows plugging in new Assertion Schemes. See
	    also <a href="#uaf-supported-assertion-schemes">UAF Supported Assertion Schemes</a>.</p>
	  
	  <p>
	    The Registration Assertion defines how and in which format a
	    cryptographic key is exchanged between the authenticator and
	    the FIDO Server.</p>
      
	  <p>
	    The Authentication Assertion defines how and in which format the
	    authenticator generates a cryptographic signature.</p>
      
	  <p>
	    The generally-supported Assertion Schemes are defined in
	    [<cite><a class="bibref" href="#bib-UAFRegistry">UAFRegistry</a></cite>].</p>
	</section>
	<section id="username-in-authenticator"> 
	  <h4 aria-level="3" role="heading" id="h4_username-in-authenticator"><span class="secno">4.1.5 </span>Username in Authenticator</h4>
	  
	  <p>
	    FIDO UAF supports authenticators acting as first authentication
	    factor (i.e. replacing username and password). In this case
	    the authenticator stores the username (uniquely identifying an
	    account at the specific relying party) internally. See
	    [<cite><a class="bibref" href="#bib-UAFAuthnrCommands">UAFAuthnrCommands</a></cite>], section "Sign Command" for details.</p>
	</section>
	<section id="tls-protected-communication"> 
	  
	  <h4 aria-level="3" role="heading" id="h4_tls-protected-communication"><span class="secno">4.1.6 </span>TLS Protected Communication</h4>
	  
	  <div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_57"><span>Note</span></div><div class="certification specific">
	    <p>
	      In order to protect the data communication
	      between FIDO UAF Client and FIDO Server a protected TLS channel
	      must be used by FIDO UAF Client (or User Agent) and the
	      Relying Party for all protocol elements.</p>
	    <ol>  
	      <li>The server endpoint of the TLS connection must be at the Relying
		Party</li>
	      <li>The client endpoint of the TLS connection must be either the FIDO UAF Client
		or the User Agent / App</li>
	      <li>TLS Client and Server should
		use TLS v1.2 or newer and should only use TLS v1.1 if TLS
		v1.2 or higher are not available. The "anon" and "null" TLS
		crypto suites are not allowed and must be rejected; insecure
		crypto-algorithms in TLS (e.g. MD5, RC4, SHA1) should be
		avoided [[SP 800-131A]].</li>
	    </ol>
	  </div></div>
      
	  We recommend, that the
	  <ol>
	    <li>
	      TLS Client verifies and validates the server
	      certificate chain according to [<cite><a class="bibref" href="#bib-RFC5280">RFC5280</a></cite>], section 6
	      "Certificate Path Validation". The certificate revocation status
	      should be checked (e.g. using OCSP [<cite><a class="bibref" href="#bib-RFC2560">RFC2560</a></cite>] or CRL based
	      validation [<cite><a class="bibref" href="#bib-RFC5280">RFC5280</a></cite>]) and the TLS server identity should be checked as well
	      [<cite><a class="bibref" href="#bib-RFC6125">RFC6125</a></cite>].</li>
	    <li>
	      TLS Client's trusted certificate root store
	      is properly maintained and at least requires the CAs
	      included in the root store to annually pass Web Trust or ETSI
	      (ETSI TS 101 456, or ETSI TS 102 042) audits for SSL CAs.</li>
	  </ol>
	  <p>
	    See [<cite><a class="bibref" href="#bib-TR-03116-4">TR-03116-4</a></cite>] and [<cite><a class="bibref" href="#bib-SHEFFER-TLS">SHEFFER-TLS</a></cite>] for more recommendations on
	    how to use TLS.</p>
	</section>
      </section>
      <section id="implementation-considerations"> 
	<h3 aria-level="2" role="heading" id="h3_implementation-considerations"><span class="secno">4.2 </span>Implementation Considerations</h3>
	
	<section id="server-challenge-and-random-numbers">
	  <h4 aria-level="3" role="heading" id="h4_server-challenge-and-random-numbers"><span class="secno">4.2.1 </span>Server Challenge and Random Numbers</h4>
	  
	  <div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_58"><span>Note</span></div><p class="certification">
	    A <a title="ServerChallenge" href="#idl-def-ServerChallenge" class="idlType"><code>ServerChallenge</code></a> needs 
	    appropriate random sources in order to be effective (see
	    [<cite><a class="bibref" href="#bib-RFC4086">RFC4086</a></cite>] for more details). The (pseudo-)random numbers used
	    for generating the Server Challenge should successfully pass
	    the randomness test specified in [<cite><a class="bibref" href="#bib-Coron99">Coron99</a></cite>] and they should follow 
	    the guideline given in [<cite><a class="bibref" href="#bib-SP800-90b">SP800-90b</a></cite>].</p></div>
	</section>
	
      </section> 
      <section id="security-considerations">
	<h3 aria-level="2" role="heading" id="h3_security-considerations"><span class="secno">4.3 </span>Security Considerations</h3>
	
	<p>
	  There is no "one size fits all" authentication method. The FIDO
	  goal is to decouple the user verification method from the
	  authentication protocol and the authentication server, and to
	  support a broad range of user verification methods and a broad
	  range of assurance levels. FIDO authenticators should be able
	  to leverage capabilities of existing computing hardware, e.g.
	  mobile devices or smart cards.</p>
	
	<p>
	  The overall assurance level of electronic user authentications
	  highly depends (a) on the security and integrity of the user's
	  equipment involved and (b) on the authentication method being
	  used to authenticate the user.</p>
	  
	<p>
	  When using FIDO, users should have the freedom to use any
	  available equipment and a variety of authentication methods.
	  The relying party needs reliable information about the security
	  relevant parts of the equipment and the authentication method
	  itself in order to determine whether the overall risk of an
	  electronic authentication is acceptable in a particular
	  business context.  The FIDO Metadata[<cite><a class="bibref" href="#bib-UAFMetadataService">UAFMetadataService</a></cite>] is intended to provide 
	  such information.</p>
      
	<p>
	  It is important for the UAF protocol to provide this kind of
	  reliable information about the security relevant parts of the
	  equipment and the authentication method itself to the FIDO
	  server.</p>
      
	<p>
	  The overall security is determined by the weakest link. In order
	  to support scalable security in FIDO, the underlying UAF
	  protocol needs to provide a very high conceptual security
	  level, so that the protocol isn't the weakest link.</p>
      
	<p>
	  <strong>Relying Parties define Acceptable Assurance Levels.</strong> The <abbr title="FIDO Alliance">FIDO Alliance</abbr>
	  envisions a broad range of FIDO UAF Clients, FIDO Authenticators and
	  FIDO Servers to be offered by various vendors. Relying parties
	  should be able to select a FIDO Server providing the
	  appropriate level of security. They should also be in a
	  position to accept FIDO Authenticators meeting the security
	  needs of the given business context, to compensate assurance
	  level deficits by adding appropriate implicit authentication
	  measures, and to reject authenticators not meeting their
	  requirements. FIDO does not mandate a very high assurance level
	  for FIDO Authenticators, instead it provides the basis for
	  authenticator and user verification method competition.</p>
      
	<p>
	  <strong>Authentication vs. Transaction Confirmation.</strong> Existing Cloud
	  services are typically based on authentication. The user launches
	  an application (i.e. User Agent) assumed to be trusted and
	  authenticates to the Cloud service in order to establish an
	  authenticated communication channel between the application and
	  the Cloud service. After this authentication, the application
	  can perform any actions to the Cloud service using the authenticated channel. 
	  The service provider will attribute all those actions to the user.
	  Essentially the user authenticates all actions performed by the
	  application in advance until the service connection or
	  authentication times out. This is a very convenient way as the
	  user doesn't get distracted by manual actions required for the
	  authentication. It is suitable for actions with low risk
	  consequences.</p>
      
	<p>
	  However, in some situations it is important for the relying
	  party to know that a user really has seen and accepted a
	  particular content before he authenticates it. This method is
	  typically being used when non-repudiation is required. The
	  resulting requirement for this scenario is called What You See
	  Is What You Sign (WYSIWYS).</p>
	  
	<p>
	  UAF supports both methods; they are called "Authentication" and
	  "Transaction Confirmation". The technical difference is, that
	  with Authentication the user confirms a random challenge, where
	  in the case of Transaction Confirmation the user also confirms
	  a human readable content, i.e. the contract. From a security
	  point, in the case of authentication the application needs to
	  be trusted as it performs any action once the authenticated
	  communication channel has been established. In the case of
	  Transaction Confirmation only the transaction confirmation 
	  display component implementing WYSIWYS needs to be trusted, 
	  not the entire application.</p>
      
	<p>
	  <strong>Distinct Attestable Security Components.</strong> For the relying party in
	  order to determine the risk associated with an authentication,
	  it is important to know details about some components of the
	  user's environment. Web Browsers typically send a "User Agent"
	  string to the web server. Unfortunately any application could
	  send any string as "User Agent" to the relying party. So this
	  method doesn't provide strong security. FIDO UAF is based on a
	  concept of cryptographic attestation. With this concept, the
	  component to be attested owns a cryptographic secret and
	  authenticates its identity with this cryptographic secret. In
	  FIDO UAF the cryptographic secret is called "Authenticator
	  Attestation Key". The relying party gets access to reference
	  data required for verifying the attestation.</p>
      
	<p>
	  In order to enable the relying party to appropriately determine
	  the risk associated with an authentication, all components
	  performing significant security functions need to be
	  attestable.</p>
      
	<p>
	  In FIDO UAF significant security functions are implemented in the
	  "FIDO Authenticators". Security functions are:</p>
	  <ol> 
	    <li>Protecting the attestation key.</li>
	    <li>Generating and protecting the Authentication key(s), typically
	      one per relying party and user account on relying party.</li>
	    <li>Verifying the user.</li>
	    <li>Providing the WYSIWYS capability ("Transaction Confirmation Display" component).</li>
	  </ol>
 
	<p>
	  Some FIDO Authenticators might implement these functions in
	  software running on the FIDO User Device, others might
	  implement these functions in "hardware", i.e. software running on a hardware 
	  segregated from the FIDO User Device. Some FIDO Authenticators
	  might even be formally evaluated and accredited to some national
	  or international scheme. Each FIDO Authenticator model has an attestation ID
	  (AAID), uniquely identifying the related security characteristics.
	  Relying parties get access to these security properties of the
	  FIDO Authenticators and the reference data required for
	  verifying the attestation.</p>
      
	<p>
	  <strong>Resilience to leaks from other verifiers.</strong> One of the important
	  issues with existing authentication solutions is a weak server
	  side implementation, affecting the security of authentication
	  of typical users to other relying parties. It is the goal of
	  the FIDO UAF protocol to decouple the security of different relying
	  parties.</p>
      
	<p>
	  <strong>Decoupling User Verification Method from Authentication Protocol.</strong>
	  In order to decouple the user verification method from the
	  authentication protocol, FIDO UAF is based on an extensible set of
	  cryptographic authentication algorithms. The cryptographic
	  secret will be unlocked after user verification by the
	  Authenticator. This secret is then used for the
	  authenticator-to-relying party authentication. The set of
	  cryptographic algorithms is chosen according to the
	  capabilities of existing cryptographic hardware and computing
	  devices. It can be extended in order to support new
	  cryptographic hardware.</p>
      
	<p>
	  <strong>Privacy Protection.</strong> Different regions in the world have different
	  privacy regulations. The FIDO UAF protocol should be acceptable in
	  all regions and hence must support the highest level of data
	  protection. As a consequence, FIDO UAF doesn't require transmission
	  of biometric data to the relying party nor does it require the
	  storage of biometric reference data [<cite><a class="bibref" href="#bib-ISOBiometrics">ISOBiometrics</a></cite>] at the relying
	  party. Additionally, cryptographic secrets used for different
	  relying parties shall not allow the parties to link actions to
	  the same user entity. UAF supports this concept, known as
	  non-linkability. Consequently, the UAF protocol doesn't require
	  a trusted third party to be involved in every transaction.</p>
	  
	<p>
	  Relying parties can interactively discover the AAIDs of all
	  enabled FIDO Authenticators on the FIDO User Device using the
	  Discovery interface [<cite><a class="bibref" href="#bib-UAFAppAPIAndTransport">UAFAppAPIAndTransport</a></cite>]. The combination of
	  AAIDs adds to the entropy provided by the client to relying
	  parties. Based on such information, relying parties can
	  fingerprint clients on the internet (see Browser Uniqueness at
	  eff.org and https://wiki.mozilla.org/Fingerprinting). In order
	  to minimize the entropy added by FIDO, the user can
	  enable/disable individual authenticators – even when they are
	  embedded in the device (see [<cite><a class="bibref" href="#bib-UAFAppAPIAndTransport">UAFAppAPIAndTransport</a></cite>], section
	  "privacy considerations").</p>
	<section id="fido-authenticator-security">
	  <h4 aria-level="3" role="heading" id="h4_fido-authenticator-security"><span class="secno">4.3.1 </span>FIDO Authenticator Security</h4>
	  
	  <p>
	    See [<cite><a class="bibref" href="#bib-UAFAuthnrCommands">UAFAuthnrCommands</a></cite>].</p>
	</section>
	<section id="cryptographic-algorithms"> 
	  <h4 aria-level="3" role="heading" id="h4_cryptographic-algorithms"><span class="secno">4.3.2 </span>Cryptographic Algorithms</h4>
	  
	  <p>
	    In order to keep key sizes small and to make private key
	    operations fast enough for small devices, it is suggested that
	    implementers prefer ECDSA [<cite><a class="bibref" href="#bib-ECDSA-ANSI">ECDSA-ANSI</a></cite>] in combination with SHA-256 / SHA-512
	    hash algorithms. However, the RSA algorithm is also supported.
	    See [<cite><a class="bibref" href="#bib-UAFRegistry">UAFRegistry</a></cite>] "Authentication Algorithms and Key Formats"
	    for a list of generally supported cryptographic algorithms.</p>
	  
	  <p>
	    One characteristic of ECDSA is that it needs to produce, for
	    each signature generation, a fresh random value. For effective
	    security, this value must be chosen randomly and uniformly from
	    a set of modular integers, using a cryptographically secure
	    process. Even slight biases in that process may be turned into
	    attacks on the signature schemes. </p>
	  <div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_59"><span>Note</span></div><p class="certification">
            If such random values cannot be provided under all possible environmental conditions, then a
	    deterministic version of ECDSA should be used (see [<cite><a class="bibref" href="#bib-RFC6979">RFC6979</a></cite>]).</p></div>
	</section>
	<section id="application-isolation"> 
	  
	  <h4 aria-level="3" role="heading" id="h4_application-isolation"><span class="secno">4.3.3 </span>Application Isolation</h4>
	  
	  <figure id="fig-fido-entity-verification-overview">	  
            <img src="./img/fido-uaf-protocol-entity-verification-overview.png" onerror="./img/fido-uaf-protocol-entity-verification-overview.png" alt="FIDO Entity Verification Overview">
	    <figcaption>Fig. <span class="figno">11</span> <span class="fig-title">FIDO Entity Verification Overview</span></figcaption>
          </figure>
	  
	  <p>
	    There are two concepts implemented in FIDO UAF to prevent malicious
	    applications from misusing AppID specific keys registered with
	    FIDO Authenticators. First concept is called "FacetID
	    Assertion" and second is based on the "KHAccessToken".  For
	    information on the FacetID concept see [<cite><a class="bibref" href="#bib-FIDOAppIDAndFacets">FIDOAppIDAndFacets</a></cite>].</p>
	  
	  <section class="certification" id="isolation-using-khaccesstoken"> 
	    <h5 aria-level="4" role="heading" id="h5_isolation-using-khaccesstoken"><span class="secno">4.3.3.1 </span>Isolation using KHAccessToken</h5>
	    
	    <p>
	      Authenticators might be implemented in dedicated hardware and
	      hence might not be able to verify the calling software entity
	      (i.e. the ASM).</p>
	    
	    <p>
	      The KHAccessToken allows restricting access to the keys
	      generated by the FIDO Authenticator to the intended ASM. It is
	      based on a Trust On First Use (TOFU) concept.</p>
	    
	    <p>
	      FIDO Authenticators are capable of binding UAuth.Key with a key
	      provided by the caller (i.e. the ASM). This key is called
	      KHAccessToken.</p>
	    
	    <p>
	      This technique allows making sure that registered keys are only
	      accessible by the caller that originally registered them. A
	      malicious App on a mobile platform won't be able to access keys
	      by bypassing the related ASM (assuming that this ASM originally
	      registered these keys).</p>
	    
	    <p>
	      The KHAccessToken is typically specific to the AppID, PersonaID,
	      ASMToken and the CallerID. See [<cite><a class="bibref" href="#bib-UAFASM">UAFASM</a></cite>] for more details.</p>
	    
	    <div class="note"><div class="note-title" aria-level="5" role="heading" id="h_note_60"><span>Note</span></div><p class="">
	      On some platforms, the ASM additionally might need special
	      permissions in order to communicate with the FIDO Authenticator. 
	      Some platforms do not provide means to reliably enforce access control among
	      applications.</p></div>
	  </section>
	</section>
	
	<section class="certification" id="tls-binding"> 
	  <h4 aria-level="3" role="heading" id="h4_tls-binding"><span class="secno">4.3.4 </span>TLS Binding</h4>
	  
	  <p>
	    Various channel binding methods have been proposed (e.g.
	    [<cite><a class="bibref" href="#bib-RFC5929">RFC5929</a></cite>] and [<cite><a class="bibref" href="#bib-ChannelID">ChannelID</a></cite>]).</p>
	  
	  <p>
	    UAF relies on TLS server authentication for binding
	    authentication keys to AppIDs. There are threats:</p>
	  <ol> 
	    <li>
	      Attackers might fraudulently get a TLS server certificate for
	      the same AppID as the relying party and they might be able to
	      manipulate the DNS system.</li>	  
	    <li>
	      Attackers might be able to steal the relying party's TLS server
	      private key and certificate and they might be able to
	      manipulate the DNS system.</li>
	  </ol> 
	  <p>
	    And there are functionality requirements:</p>
	  <ol> 
	    <li>
	      UAF transactions might span across multiple TLS sessions. As a
	      consequence, "tls-unique" defined in [RFC5929] might be
	      difficult to implement.</li>
	    <li>
	      Data centers might use SSL concentrators.</li>	  
	    <li>
	      Data centers might implement load-balancing for TLS endpoints
	      using different TLS certificates. As a consequence,
	      "tls-server-end-point" defined in [RFC5929], i.e. the hash of
	      the TLS server certificate might be inappropriate.</li>
	    <li>
	      Unfortunately, hashing of the TLS server certificate (as in
	      "tls-server-end-point") also limits the usefulness of the
	      channel binding in a particular, but quite common circumstance.
	      If the client is operated behind a trusted (to that client)
	      proxy that acts as a TLS man-in-the-middle, your client will
	      see a different certificate than the one the server is using.
	      This is actually quite common on corporate or military networks
	      with a high security posture that want to inspect all incoming
	      and outgoing traffic. If the FIDO Server just gets a hash
	      value, there's no way to distinguish this from an attack. If
	      sending the entire certificate is acceptable from a performance
	      perspective, the server can examine it and determine if it is a
	      certificate for a valid name from a non-standard issuer (likely
	      administratively trusted) or a certificate for a different name
	      (which almost certainly indicates a forwarding attack).</li>
	  </ol>
	  <p>
	    See <a href="#tlsdata-dictionary">ChannelBinding dictionary</a> for more details.</p>
	</section>
	<section class="certification" id="session-management"> 
	  <h4 aria-level="3" role="heading" id="h4_session-management"><span class="secno">4.3.5 </span>Session Management</h4>
	  <p>
	    FIDO does not define any specific session management methods.  However, several FIDO functions
	    rely on a robust session management being implemented by the relying party's web application:</p>
	  <dl> 
	    <dt><a href="#registration">FIDO Registration</a></dt>
	    <dd>A web application might trigger FIDO Registration after authenticating 
	      an existing user via legacy credentials.  
	      So the session is used to maintain the authentication state until the FIDO Registration is completed.</dd>
	    <dt><a href="#authentication">FIDO Authentication</a></dt>
	    <dd>After success FIDO Authentication, the session is used to maintain the authentication state during the 
	      operations performed by the user agent or mobile app.</dd>
	  </dl> 
	  
	  <p>
	    Best practices should be followed to implement robust session management (e.g. [<cite><a class="bibref" href="#bib-OWASP2013">OWASP2013</a></cite>]).</p>
	  
	</section>
	<section id="personas"> 
	  <h4 aria-level="3" role="heading" id="h4_personas"><span class="secno">4.3.6 </span>Personas</h4>
	  
	  <p>
	    FIDO supports unlinkability [<cite><a class="bibref" href="#bib-AnonTerminology">AnonTerminology</a></cite>] of accounts at
	    different relying parties by using relying party specific keys.</p>
	  
	  <p>
	    Sometimes users have multiple accounts at a particular relying
	    party and even want to maintain unlinkability between these
	    accounts.</p>
	  
	  <p>
	    Today, this is difficult and requires certain measures to be
	    strictly applied.</p>
	  
	  <p>
	    FIDO does not want to add more complexity to maintaining
	    unlinkability between accounts at a relying party.</p>
	  
	  <p>
	    In the case of roaming authenticators, it is recommended to use
	    different authenticators for the various personas (e.g.
	    "business", "personal"). This is possible as roaming
	    authenticators typically are small and not excessively
	    expensive.</p>
	  
	  <p>
	    In the case of bound authenticators, this is different. FIDO
	    recommends the "Persona" concept for this situation.</p>
	  
	  <p>
	    All relevant data in an authenticator are related to one Persona
	    (e.g. "business" or "personal"). Some administrative interface
	    (not standardized by FIDO) of the authenticator may allow
	    maintaining and switching Personas.</p>
	  
	  <p class="normative">
	    The authenticator <em class="rfc2119" title="MUST">MUST</em> only "know" / "recognize" data (e.g.
	    authentication keys, usernames, KeyIDs, …) related to the
	    Persona being active at that time.</p>
	  
	  <p>
	    With this concept, the User can switch to the "Personal" Persona
	    and register new accounts. After switching back to "Business"
	    Persona, these accounts will not be recognized by the
	    authenticator (until the User switches back to "Personal"
	    Persona again).</p>
	  
	  <p>
	    In order to support the persona feature, the FIDO Authenticator-specific 
	    Module API [<cite><a class="bibref" href="#bib-UAFASM">UAFASM</a></cite>] supports the use of
	    a 'PersonaID' to identify the persona in use by the
	    authenticator. How Personas are managed or communicated with
	    the user is out of scope for FIDO.</p>
	</section>
	<section id="serverdata-and-keyhandle"> 
	  <h4 aria-level="3" role="heading" id="h4_serverdata-and-keyhandle"><span class="secno">4.3.7 </span>ServerData and KeyHandle</h4>
	  
	  <p>
	    Data contained in the field serverData (see <a href="#operation-header-dictionary">Operation
	      Header dictionary</a>) of UAF requests is sent to the FIDO UAF Client and will be
	    echoed back to the FIDO Server as part of the related UAF
	    response message.</p>
	  
	  <div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_61"><span>Note</span></div><p class="certification specific">
	    The FIDO Server should not assume any kind of implicit integrity
	    protection of such data nor any implicit session binding. The FIDO
	    Server must explicitly bind the serverData to an active
	    session.</p></div>
	  
	  <div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_62"><span>Note</span></div><p class="certification specific">
	    In some situations, it is desirable to protect sensitive data
	    such that it can be stored in arbitrary places (e.g. in
	    serverData or in the KeyHandle). In such situations, the
	    confidentiality and integrity of such sensitive data must be
	    protected. This can be achieved by using a suitable encryption
	    algorithm, e.g. AES with a suitable cipher mode, e.g. CBC or
	    CTR [<cite><a class="bibref" href="#bib-CTRMode">CTRMode</a></cite>]. This cipher mode needs to be used correctly. For
	    CBC, for example, a fresh random IV for each encryption is
	    required. The data might have to be padded first in order to
	    obtain an integral number of blocks in length. The integrity
	    protection can be achieved by adding a MAC or a digital signature 
	    on the ciphertext, using a different key than for the encryption, e.g. using HMAC [<cite><a class="bibref" href="#bib-FIPS198-1">FIPS198-1</a></cite>].
	    Alternatively, an authenticated encryption scheme such as
	    AES-GCM [<cite><a class="bibref" href="#bib-SP800-38D">SP800-38D</a></cite>] or AES-CCM [<cite><a class="bibref" href="#bib-SP800-38C">SP800-38C</a></cite>] could be used.
	    Such a scheme provides both integrity and confidentiality in a
	    single algorithm and using a single key.</p></div>
	  
	  <div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_63"><span>Note</span></div><p class="certification specific">
	    When protecting serverData, the MAC or digital signature computation 
	    should include some data that binds the data to its associated message, for example by
	    re-including the challenge value in the authenticated
	    serverData.</p></div>
	</section>
	<section id="authenticator-information-retrieved-through-uaf-application-api-vs.-metadata"> 
	  <h4 aria-level="3" role="heading" id="h4_authenticator-information-retrieved-through-uaf-application-api-vs.-metadata"><span class="secno">4.3.8 </span>Authenticator Information retrieved through UAF Application API vs.
	    Metadata</h4>
	  
	  <p>
	    Several authenticator properties (e.g. UserVerificationMethods,
	    KeyProtection, TransactionConfirmationDisplay, ...) are available in the
	    metadata [<cite><a class="bibref" href="#bib-UAFAuthnrMetadata">UAFAuthnrMetadata</a></cite>] and through the FIDO UAF Application API.
	    The properties included in the metadata are authoritative and
	    are provided by a trusted source. When in doubt, decisions
	    should be based on the properties retrieved from the Metadata
	    as opposed to the data retrieved through the FIDO UAF Application API.</p>
	  
	  <p>
	    However, the properties retrieved through the FIDO UAF Application API provide
	    a good "hint" what to expect from the Authenticator. Such
	    "hints" are well suited to drive and optimize the user
	    experience.</p>
	</section>
	<section class="certification" id="policy-verification"> 
	  <h4 aria-level="3" role="heading" id="h4_policy-verification"><span class="secno">4.3.9 </span>Policy Verification</h4>
	  
	  <p>
	  FIDO UAF Response messages do not include all parameters
	  received in the related FIDO UAF request message into the
	  to-be-signed object. As a consequence, any MITM could modify
	  such entries.</p>
	
	<p>
	  FIDO Server will detect such changes if the modified value is
	  unacceptable.</p>
      
	<p>
	  For example, a MITM could replace a generic policy by a policy
	  specifying only the weakest possible FIDO Authenticator. Such a
	  change will be detected by FIDO Server if the weakest possible
	  FIDO Authenticator does not match the initial policy (see
	  <a href="#registration-response-processing-rules-for-fido-server">Registration Response Processing Rules</a> and 
	  <a href="#authentication-response-processing-rules-for-fido-server">Authentication Response Processing Rules</a>).</p>
      </section>
      <section class="certification" id="replay-attack-protection"> 
	<h4 aria-level="3" role="heading" id="h4_replay-attack-protection"><span class="secno">4.3.10 </span>Replay Attack Protection</h4>
	
	<p>
	  The FIDO UAF protocol specifies two different methods for
	  replay-attack protection:</p>
	<ol> 
	  <li>Secure transport protocol (TLS)</li>
	  <li>Server Challenge.</li>
	</ol>
	
	<p>
	  The TLS protocol by itself protects against replay-attacks when
	  implemented correctly [<cite><a class="bibref" href="#bib-TLS">TLS</a></cite>].</p>
      
	<p>
	  Additionally, each protocol message contains some random
	  bytes in the <code>ServerChallenge</code> field. The FIDO server should only
	  accept incoming FIDO UAF messages which contain a valid
	  <code>ServerChallenge</code> value. This is done by
	  verifying that the <code>ServerChallenge</code> value, sent
	  by the client, was previously generated by the FIDO server.
	  See <a title="FinalChallengeParams" href="#idl-def-FinalChallengeParams" class="idlType"><code>FinalChallengeParams</code></a>.
	</p>

	<p>
	  It should also be noted that under some (albeit unlikely)
	  circumstances, random numbers generated by the FIDO server
	  may not be unique, and in such cases, the same <code>ServerChallenge</code> 
	  may be presented more than once, making a replay attack harder to detect.
	</p>

      </section>
      <section class="certification" id="protection-against-cloned-authenticators"> 
	<h4 aria-level="3" role="heading" id="h4_protection-against-cloned-authenticators"><span class="secno">4.3.11 </span>Protection against Cloned Authenticators</h4>
	
	<p>
	  FIDO UAF relies on the UAuth.Key to be protected and managed by
	  an authenticator with the security characteristics specified
	  for the model (identified by the AAID). The security is better
	  when only a single authenticator with that specific UAuth.Key
	  instance exists. Consequently FIDO UAF specifies some
	  protection measures against cloning of authenticators.</p>
      
	<p>
	  Firstly, if the UAuth private keys are protected by appropriate
	  measures then cloning should be hard as such keys cannot be
	  extracted easily.</p>
      
	<p>
	  Secondly, UAF specifies a Signature Counter (see 
	  <a href="#authentication-response-processing-rules-for-fido-server">Authentication Response Processing Rules</a> 
	  and [<cite><a class="bibref" href="#bib-UAFAuthnrCommands">UAFAuthnrCommands</a></cite>]). 
	  This counter is increased by every signature operation. If a cloned
	  authenticator is used, then the subsequent use of the original
	  authenticator would include a signature counter lower to or
	  equal to the previous (malicious) operation. Such an incident
	  can be detected by the FIDO Server.</p>
      </section> 
      
      <section id="anti-fraud-signals"> 
	<h4 aria-level="3" role="heading" id="h4_anti-fraud-signals"><span class="secno">4.3.12 </span>Anti-Fraud Signals</h4>
      
	<p>
	  There is the potential that some attacker misuses a FIDO Authenticator for committing fraud, more specifically they would:</p>
	<ol>
	  <li>Register the authenticator to some relying party for one account</li>
	  <li>Commit fraud</li>
	  <li>Deregister the Authenticator</li>
	  <li>Register the authenticator to some relying party for another account</li>
	  <li>Commit fraud</li>
	  <li>Deregister the Authenticator</li>
	  <li>and so on...</li>
	</ol>
	<div class="note"><div class="note-title" aria-level="4" role="heading" id="h_note_64"><span>Note</span></div><p class="certification">
	  Authenticators might support a Registration Counter (<code>RegCounter</code>).  The <code>RegCounter</code> will 
	  be incremented on each registration and hence might become exceedingly high in such fraud scenarios.
	  See [<cite><a class="bibref" href="#bib-UAFAuthnrCommands">UAFAuthnrCommands</a></cite>] for more details.</p></div>
      </section> 
      
      </section>
      <section id="interoperability-considerations">
	<h3 aria-level="2" role="heading" id="h3_interoperability-considerations"><span class="secno">4.4 </span>Interoperability Considerations</h3>
	
	<p>
	  FIDO supports Web Applications, Mobile Applications and Native
	PC Applications. Such applications are referred to as FIDO enabled applications.</p>
      
      <figure id="FIDOInteroperabilityOverview">	  
        <img src="./img/fido-uaf-protocol-interoperability.png" onerror="./img/fido-uaf-protocol-interoperability.png" alt="FIDO Interoperability Overview">
	<figcaption>Fig. <span class="figno">12</span> <span class="fig-title">FIDO Interoperability Overview</span></figcaption>
      </figure>
      
      <p>
	<strong>Web applications</strong> typically consist of the web application server
	and the related Web App. The Web App code (e.g. HTML and
	JavaScript) is rendered and executed on the client side by the
	User Agent. The Web App code talks to the User Agent via a set
	of JavaScript APIs, e.g. HTML DOM. The FIDO DOM API
	is defined in [<cite><a class="bibref" href="#bib-UAFAppAPIAndTransport">UAFAppAPIAndTransport</a></cite>]. The protocol between the Web App and the
	Relying Party Web Application Server is typically proprietary.</p>

      <p>
	<strong>Mobile Apps</strong> play the role of the User Agent and the Web App
	(Client). The protocol between the Mobile App and the Relying
	Party Web Application Server is typically proprietary. </p>
      
      <p>
	<strong>Native PC Applications</strong> play the role of the User Agent, the Web
	App (Client). Those applications are typically expected to be independent from any
	particular Relying Party Web Application Server. </p>

      <p>
	It is recommended for FIDO enabled applications to use the FIDO messages according to the format specified in this document.</p>

      <p>
        It is recommended for FIDO enabled application to use the UAF HTTP Binding defined in [<cite><a class="bibref" href="#bib-UAFAppAPIAndTransport">UAFAppAPIAndTransport</a></cite>].</p>
      
      
      <div class="note"><div class="note-title" aria-level="3" role="heading" id="h_note_65"><span>Note</span></div><div class="">
	<p>
	  The KeyRegistrationData and SignedData objects 
	  [<cite><a class="bibref" href="#bib-UAFAuthnrCommands">UAFAuthnrCommands</a></cite>] are generated and signed by the FIDO
	  Authenticators and have to be verified by the FIDO Server.
	  Verification will fail if the values are modified during
	  transport.</p>
      
	<p>
	  The ASM API [UAFASM] specifies the standardized API to access
	  authenticator Specific Modules (ASMs) on Desktop PCs and Mobile
	  Devices.</p>
	
	<p>
	  The document [<cite><a class="bibref" href="#bib-UAFAuthnrCommands">UAFAuthnrCommands</a></cite>] does not specify a particular protocol or API.
	  Instead it lists the minimum data set and a specific message
	  format which needs to be transferred to and from the FIDO
	  Authenticator.</p>
      </div></div>
      </section>
    </section>
    <section class="normativeDisclaimer" id="uaf-supported-assertion-schemes"> 
      <!--OddPage--><h2 aria-level="1" role="heading" id="h2_uaf-supported-assertion-schemes"><span class="secno">5. </span>UAF Supported Assertion Schemes</h2><p><em>This section is normative.</em></p>
  
      <section id="assertion-scheme-uafv1tlv">
	<h3 aria-level="2" role="heading" id="h3_assertion-scheme-uafv1tlv"><span class="secno">5.1 </span>Assertion Scheme "UAFV1TLV"</h3>
	
    <p>
      This Assertion Scheme allows the authenticator and the FIDO
      Server to exchange an asymmetric authentication key generated
      by the Authenticator.</p>
      
    <p>
      This assertion scheme is using Tag Length Value (TLV) compact encoding to
      encode registration and authentication assertions generated by authenticators.
      This is the default assertion scheme for UAF protocol.</p>
      
    <p>
      TAGs and Algorithms are defined in [<cite><a class="bibref" href="#bib-UAFRegistry">UAFRegistry</a></cite>].</p>
      
    <p>
      The authenticator <em class="rfc2119" title="MUST">MUST</em> use a dedicated key pair (UAuth.pub/UAuth.priv) 
      suitable for the authentication algorithm specified in the 
      metadata statement [<cite><a class="bibref" href="#bib-UAFAuthnrMetadata">UAFAuthnrMetadata</a></cite>] for each relying party.  
      This key pair <em class="rfc2119" title="SHOULD">SHOULD</em> be generated as part of the registration operation.</p>
    
    <p>
      Conforming FIDO Servers <em class="rfc2119" title="MUST">MUST</em> support all
      authentication algorithms and key formats listed in document
      [<cite><a class="bibref" href="#bib-UAFRegistry">UAFRegistry</a></cite>].</p>
    
    <p>
      Conforming authenticators <em class="rfc2119" title="MUST">MUST</em> support at least one
      Authentication Algorithm and one Key Format listed in [<cite><a class="bibref" href="#bib-UAFRegistry">UAFRegistry</a></cite>].</p>
 
    <section id="keyregistrationdata">
      <h4 aria-level="3" role="heading" id="h4_keyregistrationdata"><span class="secno">5.1.1 </span>KeyRegistrationData</h4>
      
      <p>
	See [<cite><a class="bibref" href="#bib-UAFAuthnrCommands">UAFAuthnrCommands</a></cite>], section "TAG_UAFV1_KRD".
    </p></section>
    <section id="signeddata"> 
      <h4 aria-level="3" role="heading" id="h4_signeddata"><span class="secno">5.1.2 </span>SignedData</h4>
      
      <p>
	See [<cite><a class="bibref" href="#bib-UAFAuthnrCommands">UAFAuthnrCommands</a></cite>], section "TAG_UAFV1_SIGNED_DATA".
    </p></section>
  </section>
</section>
<section id="definitions"> 
  <!--OddPage--><h2 aria-level="1" role="heading" id="h2_definitions"><span class="secno">6. </span>Definitions</h2>
  
  <p>
    See [<cite><a class="bibref" href="#bib-FIDOGlossary">FIDOGlossary</a></cite>].
    
</p></section>
<section id="tof" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter">
<!--OddPage--><h2 aria-level="1" role="heading" id="h2_tof"><span class="secno">7. </span>Table of Figures</h2><ul class="tof"><li class="tofline"><a class="tocxref" href="#fig-the-uaf-architecture">Fig. <span class="figno">1</span> <span class="fig-title">The UAF Architecture</span></a></li><li class="tofline"><a class="tocxref" href="#fig-uaf-registration-message-flow">Fig. <span class="figno">2</span> <span class="fig-title">UAF Registration Message Flow</span></a></li><li class="tofline"><a class="tocxref" href="#fig-authentication-message-flow">Fig. <span class="figno">3</span> <span class="fig-title">Authentication Message Flow</span></a></li><li class="tofline"><a class="tocxref" href="#fig-transaction-confirmation-message-flow">Fig. <span class="figno">4</span> <span class="fig-title">Transaction Confirmation Message Flow</span></a></li><li class="tofline"><a class="tocxref" href="#fig-deregistration-message-flow">Fig. <span class="figno">5</span> <span class="fig-title">Deregistration Message Flow</span></a></li><li class="tofline"><a class="tocxref" href="#fig-uaf-registration-sequence-diagram">Fig. <span class="figno">6</span> <span class="fig-title">UAF Registration Sequence Diagram</span></a></li><li class="tofline"><a class="tocxref" href="#fig-uaf-registration-cryptographic-data-flow">Fig. <span class="figno">7</span> <span class="fig-title">UAF Registration Cryptographic Data Flow</span></a></li><li class="tofline"><a class="tocxref" href="#fig-uaf-authentication-sequence-diagram">Fig. <span class="figno">8</span> <span class="fig-title">UAF Authentication Sequence Diagram</span></a></li><li class="tofline"><a class="tocxref" href="#fig-uaf-authentication-cryptographic-data-flow">Fig. <span class="figno">9</span> <span class="fig-title">UAF Authentication Cryptographic Data Flow</span></a></li><li class="tofline"><a class="tocxref" href="#fig-attestation-certificate-chain">Fig. <span class="figno">10</span> <span class="fig-title">Attestation Certificate Chain</span></a></li><li class="tofline"><a class="tocxref" href="#fig-fido-entity-verification-overview">Fig. <span class="figno">11</span> <span class="fig-title">FIDO Entity Verification Overview</span></a></li><li class="tofline"><a class="tocxref" href="#FIDOInteroperabilityOverview">Fig. <span class="figno">12</span> <span class="fig-title">FIDO Interoperability Overview</span></a></li></ul></section>


<section id="references" class="appendix" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter"><!--OddPage--><h2 aria-level="1" role="heading" id="h2_references"><span class="secno">A. </span>References</h2><section id="normative-references" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter"><h3 aria-level="2" role="heading" id="h3_normative-references"><span class="secno">A.1 </span>Normative references</h3><dl class="bibliography" about=""><dt id="bib-ABNF">[ABNF]</dt><dd rel="dcterms:requires">D. Crocker, Ed.; P. Overell. <a href="https://tools.ietf.org/html/rfc5234"><cite>Augmented BNF for Syntax Specifications: ABNF</cite></a>. January 2008. Internet Standard. URL: <a href="https://tools.ietf.org/html/rfc5234">https://tools.ietf.org/html/rfc5234</a>
</dd><dt id="bib-ChannelID">[ChannelID]</dt><dd rel="dcterms:requires">D. Balfanz <a href="http://tools.ietf.org/html/draft-balfanz-tls-channelid"><cite>Transport Layer Security (TLS) Channel IDs</cite></a>. (Work In Progress) URL: <a href="http://tools.ietf.org/html/draft-balfanz-tls-channelid">http://tools.ietf.org/html/draft-balfanz-tls-channelid</a>
</dd><dt id="bib-Coron99">[Coron99]</dt><dd rel="dcterms:requires">J. Coron and D. Naccache <a href="http://www.jscoron.fr/publications/universal.pdf"><cite>An accurate evaluation of Maurer's universal test</cite></a>. LNCS 1556, February 1999, URL: <a href="http://www.jscoron.fr/publications/universal.pdf">http://www.jscoron.fr/publications/universal.pdf</a>
</dd><dt id="bib-FIDOAppIDAndFacets">[FIDOAppIDAndFacets]</dt><dd rel="dcterms:requires">D. Balfanz, B. Hill, R. Lindemann, D. Baghdasaryan, <cite>FIDO AppID and Facets v1.0</cite>. FIDO Alliance Proposed Standard. URLs: <br>HTML: <a href="https://fidoalliance.org/specs/fido-uaf-v1.0-ps-20141208/fido-appid-and-facets-v1.0-ps-20141208.html">fido-appid-and-facets-v1.0-ps-20141208.html</a><br>PDF: <a href="https://fidoalliance.org/specs/fido-uaf-v1.0-ps-20141208/fido-appid-and-facets-v1.0-ps-20141208.pdf">fido-appid-and-facets-v1.0-ps-20141208.pdf</a>
</dd><dt id="bib-FIDOGlossary">[FIDOGlossary]</dt><dd rel="dcterms:requires">R. Lindemann, D. Baghdasaryan, B. Hill, J. Hodges, <cite>FIDO Technical Glossary</cite>. FIDO Alliance Proposed Standard. URLs: <br>HTML: <a href="https://fidoalliance.org/specs/fido-uaf-v1.0-ps-20141208/fido-glossary-v1.0-ps-20141208.html">fido-glossary-v1.0-ps-20141208.html</a> <br>PDF: <a href="https://fidoalliance.org/specs/fido-uaf-v1.0-ps-20141208/fido-glossary-v1.0-ps-20141208.pdf">fido-glossary-v1.0-ps-20141208.pdf</a>
</dd><dt id="bib-FIPS180-4">[FIPS180-4]</dt><dd rel="dcterms:requires"><a href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf"><cite>FIPS PUB 180-4: Secure Hash Standard (SHS)</cite></a>. National Institute of Standards and Technology, March 2012, URL: <a href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf</a>
</dd><dt id="bib-JWA">[JWA]</dt><dd rel="dcterms:requires">M. Jones <a href="http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms"><cite>JSON Web Algorithms (JWA)</cite></a>. Internet-Draft (Work in progress.) URL: <a href="http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms">http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms</a>
</dd><dt id="bib-JWK">[JWK]</dt><dd rel="dcterms:requires">Mike Jones. <a href="http://tools.ietf.org/html/draft-ietf-jose-json-web-key-11"><cite>JSON Web Key (JWK)</cite></a>. 28 May 2013. Internet Draft. URL: <a href="http://tools.ietf.org/html/draft-ietf-jose-json-web-key-11">http://tools.ietf.org/html/draft-ietf-jose-json-web-key-11</a>
</dd><dt id="bib-RFC1321">[RFC1321]</dt><dd rel="dcterms:requires">R. Rivest, <a href="http://www.ietf.org/rfc/rfc1321.txt"><cite>The MD5 Message-Digest Algorithm (RFC 1321)</cite></a>, IETF, April 1992, URL: <a href="http://www.ietf.org/rfc/rfc1321.txt">http://www.ietf.org/rfc/rfc1321.txt</a>
</dd><dt id="bib-RFC2119">[RFC2119]</dt><dd rel="dcterms:requires">S. Bradner. <a href="https://tools.ietf.org/html/rfc2119"><cite>Key words for use in RFCs to Indicate Requirement Levels</cite></a>. March 1997. Best Current Practice. URL: <a href="https://tools.ietf.org/html/rfc2119">https://tools.ietf.org/html/rfc2119</a>
</dd><dt id="bib-RFC3629">[RFC3629]</dt><dd rel="dcterms:requires">F. Yergeau. <a href="https://tools.ietf.org/html/rfc3629"><cite>UTF-8, a transformation format of ISO 10646</cite></a>. November 2003. Internet Standard. URL: <a href="https://tools.ietf.org/html/rfc3629">https://tools.ietf.org/html/rfc3629</a>
</dd><dt id="bib-RFC4086">[RFC4086]</dt><dd rel="dcterms:requires">D. Eastlake 3rd, J. Schiller, S. Crocker <a href="http://www.ietf.org/rfc/rfc4086.txt"><cite>Randomness Requirements for Security (RFC 4086)</cite></a>, IETF, June 2005, URL: <a href="http://www.ietf.org/rfc/rfc4086.txt">http://www.ietf.org/rfc/rfc4086.txt</a>
</dd><dt id="bib-RFC4627">[RFC4627]</dt><dd rel="dcterms:requires">D. Crockford. <a href="https://tools.ietf.org/html/rfc4627"><cite>The application/json Media Type for JavaScript Object Notation (JSON)</cite></a>. July 2006. Informational. URL: <a href="https://tools.ietf.org/html/rfc4627">https://tools.ietf.org/html/rfc4627</a>
</dd><dt id="bib-RFC4648">[RFC4648]</dt><dd rel="dcterms:requires">S. Josefsson, <a href="http://www.ietf.org/rfc/rfc4648.txt"><cite>The Base16, Base32, and Base64 Data Encodings (RFC 4648)</cite></a>, IETF, October 2006, URL: <a href="http://www.ietf.org/rfc/rfc4648.txt">http://www.ietf.org/rfc/rfc4648.txt</a>
</dd><dt id="bib-RFC5056">[RFC5056]</dt><dd rel="dcterms:requires">N. Williams, <a href="http://www.ietf.org/rfc/rfc5056.txt"><cite>On the Use of Channel Bindings to Secure Channels (RFC 5056)</cite></a>, IETF, November 2007, URL: <a href="http://www.ietf.org/rfc/rfc5056.txt">http://www.ietf.org/rfc/rfc5056.txt</a>
</dd><dt id="bib-RFC5280">[RFC5280]</dt><dd rel="dcterms:requires">D. Cooper, S. Santesson, s. Farrell, S.Boeyen, R. Housley, W. Polk; <a href="http://www.ietf.org/rfc/rfc5280.txt"><cite>Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</cite></a>, IETF, May 2008, URL: <a href="http://www.ietf.org/rfc/rfc5280.txt">http://www.ietf.org/rfc/rfc5280.txt</a>
</dd><dt id="bib-RFC5929">[RFC5929]</dt><dd rel="dcterms:requires">J. Altman, N. Williams, L. Zhu, <a href="http://www.ietf.org/rfc/rfc5929.txt"><cite>Channel Bindings for TLS (RFC 5929)</cite></a>, IETF, July 2010, URL: <a href="http://www.ietf.org/rfc/rfc5929.txt">http://www.ietf.org/rfc/rfc5929.txt</a>
</dd><dt id="bib-RFC6234">[RFC6234]</dt><dd rel="dcterms:requires">D. Eastlake 3rd, T. Hansen, <a href="http://www.ietf.org/rfc/rfc6234.txt"><cite>US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF) (RFC 6234)</cite></a>, IETF, May 2011, URL: <a href="http://www.ietf.org/rfc/rfc6234.txt">http://www.ietf.org/rfc/rfc6234.txt</a>
</dd><dt id="bib-RFC6979">[RFC6979]</dt><dd rel="dcterms:requires">T. Pornin, <a href="http://www.ietf.org/rfc/rfc6979.txt"><cite>Deterministic Usage of the Digital Signature Algorithm (DSA) and Elliptic Curve Digital Signature Algorithm (ECDSA) (RFC6979)</cite></a>, IETF, August 2013, URL: <a href="http://www.ietf.org/rfc/rfc6979.txt">http://www.ietf.org/rfc/rfc6979.txt</a>
</dd><dt id="bib-SP800-90b">[SP800-90b]</dt><dd rel="dcterms:requires">Elaine Baker and John Kelsey, <a href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf"><cite>NIST Special Publication 800-90b: Recommendation for the Entropy Sources Used for Random Bit Generation</cite></a>. National Institute of Standards and Technology, August 2012, URL: <a href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf</a>
</dd><dt id="bib-UAFASM">[UAFASM]</dt><dd rel="dcterms:requires">D. Baghdasaryan, J. Kemp, R. Lindemann, B. Hill, R. Sasson, <cite>FIDO UAF Authenticator-Specific Module API</cite>. FIDO Alliance Proposed Standard. URLs: <br>HTML: <a href="https://fidoalliance.org/specs/fido-uaf-v1.0-ps-20141208/fido-uaf-asm-api-v1.0-ps-20141208.html">fido-uaf-asm-api-v1.0-ps-20141208.html</a><br>PDF:  <a href="https://fidoalliance.org/specs/fido-uaf-v1.0-ps-20141208/fido-uaf-asm-api-v1.0-ps-20141208.pdf">fido-uaf-asm-api-v1.0-ps-20141208.pdf</a>
</dd><dt id="bib-UAFAppAPIAndTransport">[UAFAppAPIAndTransport]</dt><dd rel="dcterms:requires">B. Hill, D. Baghdasaryan, B. Blanke, <cite>FIDO UAF Application API and Transport Binding Specification</cite>. FIDO Alliance Proposed Standard. URLs: <br>HTML: <a href="https://fidoalliance.org/specs/fido-uaf-v1.0-ps-20141208/fido-uaf-client-api-transport-v1.0-ps-20141208.html">fido-uaf-client-api-transport-v1.0-ps-20141208.html</a><br>PDF: <a href="https://fidoalliance.org/specs/fido-uaf-v1.0-ps-20141208/fido-uaf-client-api-transport-v1.0-ps-20141208.pdf">fido-uaf-client-api-transport-v1.0-ps-20141208.pdf</a>
</dd><dt id="bib-UAFAuthnrCommands">[UAFAuthnrCommands]</dt><dd rel="dcterms:requires">D. Baghdasaryan, J. Kemp, R. Lindemann, R. Sasson, B. Hill, <cite>FIDO UAF Authenticator Commands v1.0</cite>. FIDO Alliance Proposed Standard. URLs: <br>HTML:  <a href="https://fidoalliance.org/specs/fido-uaf-v1.0-ps-20141208/fido-uaf-authnr-cmds-v1.0-ps-20141208.html">fido-uaf-authnr-cmds-v1.0-ps-20141208.html</a><br>PDF: <a href="https://fidoalliance.org/specs/fido-uaf-v1.0-ps-20141208/fido-uaf-authnr-cmds-v1.0-ps-20141208.pdf">fido-uaf-authnr-cmds-v1.0-ps-20141208.pdf</a>
</dd><dt id="bib-UAFAuthnrMetadata">[UAFAuthnrMetadata]</dt><dd rel="dcterms:requires">B. Hill, D. Baghdasaryan, J. Kemp, <cite>FIDO UAF Authenticator Metadata Statements v1.0</cite>. FIDO Alliance Proposed Standard. URLs: <br>HTML:  <a href="https://fidoalliance.org/specs/fido-uaf-v1.0-ps-20141208/fido-uaf-authnr-metadata-v1.0-ps-20141208.html">fido-uaf-authnr-metadata-v1.0-ps-20141208.html</a><br>PDF: <a href="https://fidoalliance.org/specs/fido-uaf-v1.0-ps-20141208/fido-uaf-authnr-metadata-v1.0-ps-20141208.pdf">fido-uaf-authnr-metadata-v1.0-ps-20141208.pdf</a>
</dd><dt id="bib-UAFRegistry">[UAFRegistry]</dt><dd rel="dcterms:requires">R. Lindemann, D. Baghdasaryan, B. Hill, <cite>FIDO UAF Registry of Predefined Values</cite>. FIDO Alliance Proposed Standard. URLs: <br>HTML: <a href="https://fidoalliance.org/specs/fido-uaf-v1.0-ps-20141208/fido-uaf-reg-v1.0-ps-20141208.html">fido-uaf-reg-v1.0-ps-20141208.html</a> <br>PDF: <a href="https://fidoalliance.org/specs/fido-uaf-v1.0-ps-20141208/fido-uaf-reg-v1.0-ps-20141208.pdf">fido-uaf-reg-v1.0-ps-20141208.pdf</a>
</dd><dt id="bib-WebIDL-ED">[WebIDL-ED]</dt><dd rel="dcterms:requires">Cameron McCormack, <a href="http://heycam.github.io/webidl/"><cite>Web IDL</cite></a>, W3C.  Editor's Draft 13 November 2014.  URL: <a href="http://heycam.github.io/webidl/">http://heycam.github.io/webidl/</a>
</dd></dl></section><section id="informative-references" typeof="bibo:Chapter" resource="#ref" rel="bibo:Chapter"><h3 aria-level="2" role="heading" id="h3_informative-references"><span class="secno">A.2 </span>Informative references</h3><dl class="bibliography" about=""><dt id="bib-AnonTerminology">[AnonTerminology]</dt><dd rel="dcterms:references"><a href="http://dud.inf.tu-dresden.de/literatur/Anon_Terminology_v0.34.pdf"><cite>"Anonymity, Unlinkability, Unobservability, Pseudonymity, and Identity Management - A Consolidated Proposal for Terminology", Version 0.34,</cite></a>. A. Pfitzmann and M. Hansen, August 2010. URL: <a href="http://dud.inf.tu-dresden.de/literatur/Anon_Terminology_v0.34.pdf">http://dud.inf.tu-dresden.de/literatur/Anon_Terminology_v0.34.pdf</a>
</dd><dt id="bib-CTRMode">[CTRMode]</dt><dd rel="dcterms:references">H. Lipmea, P. Rogaway, D. Wagner, <a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/ctr/ctr-spec.pdf"><cite>Comments to NIST concerning AES Modes of Operation: CTR-Mode Encryption</cite></a>. National Institute of Standards and Technology, accessed March 11, 2014, URL: <a href="http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/ctr/ctr-spec.pdf">http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/ctr/ctr-spec.pdf</a>
</dd><dt id="bib-ECDSA-ANSI">[ECDSA-ANSI]</dt><dd rel="dcterms:references"><a href="http://webstore.ansi.org/RecordDetail.aspx?sku=ANSI+X9.62%3A2005"><cite>Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA), ANSI X9.62-2005</cite></a>. American National Standards Institute, November 2005, URL: <a href="http://webstore.ansi.org/RecordDetail.aspx?sku=ANSI+X9.62%3A2005">http://webstore.ansi.org/RecordDetail.aspx?sku=ANSI+X9.62%3A2005</a>
</dd><dt id="bib-FIDOSecRef">[FIDOSecRef]</dt><dd rel="dcterms:references">R. Lindemann, D. Baghdasaryan, B. Hill, <cite>FIDO Security Reference</cite>. FIDO Alliance Proposed Standard. URLs: <br>HTML: <a href="https://fidoalliance.org/specs/fido-uaf-v1.0-ps-20141208/fido-security-ref-v1.0-ps-20141208.html">fido-security-ref-v1.0-ps-20141208.html</a><br>PDF: <a href="https://fidoalliance.org/specs/fido-uaf-v1.0-ps-20141208/fido-security-ref-v1.0-ps-20141208.pdf">fido-security-ref-v1.0-ps-20141208.pdf</a>
</dd><dt id="bib-FIPS198-1">[FIPS198-1]</dt><dd rel="dcterms:references"><a href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf"><cite>FIPS PUB 198-1: The Keyed-Hash Message Authentication Code (HMAC)</cite></a>. National Institute of Standards and Technology, July 2008, URL: <a href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf</a>
</dd><dt id="bib-ISOBiometrics">[ISOBiometrics]</dt><dd rel="dcterms:references">Project Editor, <a href="http://isotc.iso.org/livelink/livelink/fetch/2000/2122/327993/327973/654118/6687752/N_3004_JTC_1_SC_37_-_Harmonized_Biometric_Vocabulary_-_for_information.pdf?nodeid=6719683&amp;vernum=0"><cite>Harmonized Biometric Vocabulary</cite></a>. ISO/IEC JTC 1. 15 November 2007, URL: <a href="http://isotc.iso.org/livelink/livelink/fetch/2000/2122/327993/327973/654118/6687752/N_3004_JTC_1_SC_37_-_Harmonized_Biometric_Vocabulary_-_for_information.pdf?nodeid=6719683&amp;vernum=0">http://isotc.iso.org/livelink/...</a>
</dd><dt id="bib-OWASP2013">[OWASP2013]</dt><dd rel="dcterms:references"><a href="http://owasptop10.googlecode.com/files/OWASP%20Top%2010%20-%202013.pdf"><cite>OWASP 2013</cite></a>. OWASP Top 10 - 2013. The Ten Most Critical Web Application Security Risks
</dd><dt id="bib-RFC2560">[RFC2560]</dt><dd rel="dcterms:references">M. Myers; R. Ankney; A. Malpani; S. Galperin; C. Adams. <a href="https://tools.ietf.org/html/rfc2560"><cite>X.509 Internet Public Key Infrastructure Online Certificate Status Protocol - OCSP</cite></a>. June 1999. Proposed Standard. URL: <a href="https://tools.ietf.org/html/rfc2560">https://tools.ietf.org/html/rfc2560</a>
</dd><dt id="bib-RFC6125">[RFC6125]</dt><dd rel="dcterms:references">P. Saint-Andre, J. Hodges, <a href="http://www.ietf.org/rfc/rfc6125.txt"><cite>Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS) (RFC 6125)</cite></a>, IETF, March 2011, URL: <a href="http://www.ietf.org/rfc/rfc6125.txt">http://www.ietf.org/rfc/rfc6125.txt</a>
</dd><dt id="bib-RFC6287">[RFC6287]</dt><dd rel="dcterms:references">D. M'Raihi, J. Rydell, S. Bajaj, S. Machani, D. Naccache, <a href="http://www.ietf.org/rfc/rfc6287.txt"><cite>OCRA: OATH Challenge-Response Algorithm (RFC 6287)</cite></a>, IETF, June 2011, URL: <a href="http://www.ietf.org/rfc/rfc6287.txt">http://www.ietf.org/rfc/rfc6287.txt</a>
</dd><dt id="bib-SHEFFER-TLS">[SHEFFER-TLS]</dt><dd rel="dcterms:references">Y. Sheffer, R. Holz, P. Saint-Andre <a href="https://tools.ietf.org/html/draft-sheffer-tls-bcp"><cite>Recommendations for Secure Use of TLS and DTLS</cite></a>. Internet-Draft (Work in progress.) URL: <a href="https://tools.ietf.org/html/draft-sheffer-tls-bcp">https://tools.ietf.org/html/draft-sheffer-tls-bcp</a>
</dd><dt id="bib-SP800-38C">[SP800-38C]</dt><dd rel="dcterms:references">M. Dworkin, <a href="http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C_updated-July20_2007.pdf"><cite>NIST Special Publication 800-38C: Recommendation for Block Cipher Modes of Operation: The CCM Mode for Authentication and Confidentiality</cite></a>. National Institute of Standards and Technology, July 2007, URL: <a href="http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C_updated-July20_2007.pdf">http://csrc.nist.gov/publications/nistpubs/800-38C/SP800-38C_updated-July20_2007.pdf</a>
</dd><dt id="bib-SP800-38D">[SP800-38D]</dt><dd rel="dcterms:references">M. Dworkin. <a href="http://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf"><cite> NIST Special Publication 800-38D: Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC</cite></a>. November 2007 URL: <a href="http://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf">http://csrc.nist.gov/publications/nistpubs/800-38D/SP-800-38D.pdf</a>
</dd><dt id="bib-SP800-63">[SP800-63]</dt><dd rel="dcterms:references">W. Burr, D. Dodson, E. Newton, R. Perlner, W.T. Polk, S. Gupta and E. Nabbus, <a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63-2.pdf"><cite>NIST Special Publication 800-63-2: Electronic Authentication Guideline</cite></a>. National Institute of Standards and Technology, August 2013, URL: <a href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63-2.pdf">http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63-2.pdf</a>
</dd><dt id="bib-TLS">[TLS]</dt><dd rel="dcterms:references">T. Dierks; E. Rescorla. <a href="http://tools.ietf.org/html/rfc5246"><cite>The Transport Layer Security (TLS) Protocol, Version 1.2</cite></a>. August 2008. RFC 5246. URL: <a href="http://tools.ietf.org/html/rfc5246">http://tools.ietf.org/html/rfc5246</a>
</dd><dt id="bib-TR-03116-4">[TR-03116-4]</dt><dd rel="dcterms:references"><a href="https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/TechnischeRichtlinien/TR03116/BSI-TR-03116-4.pdf"><cite>Technische Richtlinie TR-03116-4: eCard-Projekte der Bundesregierung: Teil 4 – Vorgaben für Kommunikationsverfahren im eGovernment</cite></a>. Bundesamt für Sicherheit in der Informationstechnik, 2013, URL: <a href="https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/TechnischeRichtlinien/TR03116/BSI-TR-03116-4.pdf">https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Publikationen/TechnischeRichtlinien/TR03116/BSI-TR-03116-4.pdf</a>
</dd><dt id="bib-UAFMetadataService">[UAFMetadataService]</dt><dd rel="dcterms:references">R. Lindemann, B. Hill, D. Baghdasaryan, <cite>FIDO UAF Metadata Service v1.0</cite>. FIDO Alliance Proposed Standard. URLs: <br>HTML: <a href="https://fidoalliance.org/specs/fido-uaf-v1.0-ps-20141208/fido-uaf-metadata-service-v1.0-ps-20141208.html">fido-uaf-metadata-service-v1.0-ps-20141208.html</a> <br>PDF: <a href="https://fidoalliance.org/specs/fido-uaf-v1.0-ps-20141208/fido-uaf-metadata-service-v1.0-ps-20141208.pdf">fido-uaf-metadata-service-v1.0-ps-20141208.pdf</a>
</dd><dt id="bib-WebIDL">[WebIDL]</dt><dd rel="dcterms:references">Cameron McCormack. <a href="http://www.w3.org/TR/WebIDL/"><cite>Web IDL</cite></a>. 19 April 2012. W3C Candidate Recommendation. URL: <a href="http://www.w3.org/TR/WebIDL/">http://www.w3.org/TR/WebIDL/</a>
</dd></dl></section></section></body></html>