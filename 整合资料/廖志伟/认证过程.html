<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/272632; Windows/6.1.7600;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="758"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><font color="#939600" style="font-size: 23px;">1.客户端请求fidoServer </font><div><font color="#939600" style="font-size: 23px;">   </font>客户端发送userName给服务器</div><div style="font-size: 23px;"><font color="#939600">2.服务器返回客户端信息如下：</font><font color="#939600">  <span style="font-size: 17px;"> </span></font><img src="认证过程_files/9.png" type="image/png" height="214" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;" width="1232"/></div><div><span style="font-size: 23px;"> </span>和注册的过程一样：信息包含header[upv,severData,challenge,],appId,challenge，keyIDs</div><div style="font-size: 23px;"><font color="#939600">3、服务器的信息传递给了fido客户端，fidoClient做以下处理：</font></div><div><span style="color: rgb(147, 150, 0); font-size: 23px;">   </span>形成以下信息后，再向ASM发送消息：</div><div>   dictionary AuthenticateIn {</div>
    required DOMString appID;<br/>
    DOMString[]        keyIDs;<br/>
    required DOMString finalChallenge;//<span style="line-height: 15px; widows: 1;">FinalCallengeParams就是appID 和challenge,facetIdf的json字符串的信息(Base64b编码形成的)</span><br/>
    Transaction[]      transaction;//暂时为空<br/>
};
<div style="font-size: 23px;"><span style="color: rgb(147, 150, 0); widows: 1;">4.ASM收到 fidoClient发送的消息：</span></div><div style="font-size: 23px;"><span style="widows: 1;"><font color="#939600">     </font> <span style="font-size: 17px;">做</span><span style="font-size: 17px;">以下操作：</span></span></div><div style="font-size: 23px;"><span style="widows: 1;"><span style="font-size: 17px;">        1.找到对应的认证器</span></span></div><div style="font-size: 23px;"><span style="widows: 1;"><span style="font-size: 17px;">        2.如果用户没有注册认证器，则告诉返回没有注册的响应字段</span></span></div><div style="font-size: 23px;"><span style="widows: 1;"><span style="font-size: 17px;">        3.ASM要求认证器去检验用户的身份，如果用户的身份检验失败，则返回被拒绝的响应字段</span></span></div><div style="font-size: 23px;"><span style="widows: 1;"><span style="font-size: 17px;">        4.生成KeyAcessToken的数值</span></span></div><div style="font-size: 23px;"><span style="widows: 1;"><span style="font-size: 17px;">        5.用户认证器的自己的hash算法计算finalChallegne的摘要</span></span></div><div style="font-size: 23px;"><span style="widows: 1;"><span style="font-size: 17px;">        6.如果是二因子的认证器，发现KeyIDs为空，则返回拒绝的响应字段</span></span></div><div style="font-size: 23px;"><span style="widows: 1;"><span style="font-size: 17px;">        7.如果keyIDs不为空，如果为绑定类型的认证器，则通过AppId，KeyId去ASM的数据库中查找对应的KeyHandle,如果为非绑定类型的认证器，则直接把KeyId作为Keyhandle发送给认证器</span></span></div><div style="font-size: 23px;"><span style="widows: 1;"><span style="font-size: 17px;">         8.生成向认证器请求的数据如下：</span></span></div><div style="font-size: 23px;"><span style="widows: 1;"><span style="font-size: 17px;">        obejct{</span></span></div><div><span style="widows: 1;"><span style="font-size: 17px;">             </span>  </span>TAG_UAFV1_SIGN_CMD</div><div>               TAG_AUTHENTICATOR_INDEX//验证过程中为0001</div><div>               TAG_FINAL_CHALLENGE</div><div>               TAG_TRANSACTION_CONTENT//可能是空的</div><div>               TAG_KEYHANDLE_ACCESS_TOKEN </div><div>               TAG_USERVERIFY_TOKEN</div><div>               TAG_KEYHANDLE</div><div style="font-size: 23px;"><span style="widows: 1;"><span style="font-size: 17px;">        }</span></span></div><div style="font-size: 23px;"><span style="widows: 1;"><span style="font-size: 17px;">        9.将上述信息发送给验证器</span></span></div><div style="font-size: 23px;"><span style="color: rgb(147, 150, 0);">5.认证器收到消息后：</span></div><div><font color="#939600" style="font-size: 23px;">       </font>做如下操作：</div><div>         1.更新KeyAcessToken的数值</div><div>         2.查看用户的是否有取消操作的动作，如果有，则返回取消操作的动作</div><div>         3.如果用户没有注册，则返回没有注册的验证信息</div><div>         4.用验证器的内部密钥来解密KeyHandle的数值(注：如果是一因子的非绑定认证器：用KeyIds去匹配所有存储在认证器内部的KeyHandle)</div><div>         5.用KeyAcessToken的数值来过滤第4步找到的所有的KeyHandle（比较两者的摘要是否一致）</div><div>         6.经过过滤之后，如果KeyHandle的个数为零，则返回拒绝验证的操作码</div><div>         7. 如果剩下的KeyHandle的个数的大于1</div><div>         8.如果剩下的KeyHandle的等于1：</div><div>              a.形成认证器返回的响应字段</div><div>              b.产生以下的信息结构体：</div><div>               obejct{</div><div>                 TAG_AAID//认证器的类型</div><div>                 TAG_ASSERTION_INFO//和每次操作的类型有关</div><div>                 TAG_FINAL_CHALLENGE// 对finalChanllegeParams的摘要信息</div><div>                 TAG_KEYID//KeyId(用来寻找KeyHandle)</div><div>                 TAG_COUNTERS// 签名的次数的计数器</div><div>                 TAG_PUB_KEY// 认证产生的公钥</div><div>                 TAG_SIGNATURE//用KeyHandle中的私钥形成的摘要</div><div>              }</div><div>             c.从b步骤的结构体中，在再次形成最后的结构体</div><div>              object{</div><div>                     TAG_STATUS_CODE//响应字段</div><div>                     TAG_USERNAME//用户名(一因子的应该是在KeyHandle里面的)</div><div>                     TAG_KEYHANDLE// keyHandle(加密后的)</div><div>                     TAG_AUTHENTICATOR_ASSERTION//(步骤b中的信息结构体)</div><div>              }</div><div style="font-size: 23px;"><span style="background-color: rgb(255, 255, 255); color: rgb(147, 150, 0); text-align: left; widows: 1;">6.认证器返回给ASM的信息后：</span></div><div style="font-size: 23px;"><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;"><font color="#939600">       </font> <span style="font-size: 17px;">ASM收到认证器的消息后，形成一下信息体，传递给fidoClient</span></span></div><div><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;"><span style="font-size: 17px;">         </span> </span>dictionary AuthenticateOut {</div>
    required DOMString assertion;//认证器返回给ASM的信息[<span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">RegisterObject]的内容</span><br/>
    required DOMString assertionScheme;//UAF1VTLV<br/>
};
<div style="font-size: 23px;"><span style="color: rgb(147, 150, 0);">7.FidoClient 收到ASM的返回的信息,做如下操作：</span></div><div style="font-size: 23px;"><span style="color: rgb(147, 150, 0);">   </span> <span style="font-size: medium;">形成信息体:</span><span style="font-size: medium;"> RegisterOut{</span></div><div style="font-size: medium;">               Obejct Header//upv,op,appId,severData</div><div style="font-size: medium;">               FinalChanllege fcParams//拿给服务器去校验FinalChallege</div><div style="font-size: medium;">               RegisterOut  args//ASM 返回给fidoClient的信息<br/>
        } </div><div style="font-size: medium;">       然后发送给服务器</div><div style="font-size: medium;">     <img src="认证过程_files/10.png" type="image/png" height="238" style="cursor: default;cursor: default;" width="1235"/></div><div style="font-size: medium;"><span style="font-size: 23px;"><font color="#939600">8.fido服务器验证信息的有效性:</font></span></div><div style="font-size: medium;"><span style="font-size: 23px;"><font color="#939600">   </font> <span style="font-size: 17px;">1.先解析</span></span>assertion 字段，得到<span style="font-size: 17px;">签名字数的计数器，验证计数器是否一致，防止被克隆</span></div><div style="font-size: medium;"><span style="font-size: 23px;"><span style="font-size: 17px;">     2.再用公钥去验证整个签名信息的一致性,保证信息是客户端发送的</span></span></div><div style="font-size: medium;"><span style="font-size: 23px;"><span style="font-size: 17px;">     3.计算</span></span>FinalChanllege fcParams的摘要数值，然后和发送过来的fc的摘要数值进行比较，如果一直，用户的验证是成功的.</div><div style="font-size: medium;"><span style="background-color: rgb(255, 255, 255); font-family: sans-serif; text-align: left; widows: 1;"> </span></div></div>
</div></body></html> 