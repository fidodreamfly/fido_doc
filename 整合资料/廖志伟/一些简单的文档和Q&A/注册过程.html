<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/272632; Windows/6.1.7600;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="670"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div><span style="color: rgb(147, 150, 0); font-size: 23px;">1.用户发送信息 facetID和userName</span></div><div>  facetID :android apk 的hash 摘要</div><div>  userName:用户名字</div><div><span style="font-size: 23px;"><font color="#939600">2.sever接收信息，然后发送UAFregRequest信息：</font></span> </div><div><img src="注册过程_files/1.png" type="image/png" height="268" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;" width="1177"/></div><div><br/></div><div>服务器的信息包含：heade[upv,severData,op]policy,AppId,challenge</div><div><br/></div><div style="font-size: 23px;"><font color="#939600">3.服务器的信息传递给了fido客户端（fidoClient先做处理）</font></div><div style="font-size: 23px;"><font color="#2D4FC9">1.fidoClient对 appId 进行处理：</font></div><div><font color="#FF0000"> </font>1.如果AppID不是安全链接以及满足facetID的要求，就不做额外的处理</div><div>2如果AppID是空的，那么FidoClient 必须用facetId 代替Appid)<br/></div><div>3如果FaceID 含有https的标志，没有额外的处理是必要的，操作可以继续进行。如果想要的话，该算法可以在不需要的情况下继续以缓存的方式继续进行缓存。）</div><div style="font-size: 20px;"><font color="#3665EE">2.fidoClient对 形成  <span style="line-height: 15.6px; widows: 1;"><a href="file:///#widl-RegisterIn-finalChallenge" style="border-bottom-width: 1px; border-bottom-style: dotted; border-bottom-color: rgb(255, 69, 0); text-decoration: none;">finalChallenge</a></span><span style="line-height: 15.6px; widows: 1;">;</span></font></div><div style="widows: 1;"><span style="line-height: 15px;">FinalCallengeParams就是appID 和challenge,facetIdf的json字符串的信息(Base64b编码形成的)</span></div><div style="widows: 1;"><span style="line-height: 15px;"><br/></span></div><div style="widows: 1;"><font color="#3665EE"><span style="line-height: 15px;"><br/></span></font></div><div style="widows: 1; font-size: 23px;"><font color="#939600">4.fido Client把信息了传递给ASM。</font></div><div>     fidoClient形成以下结构体给ASM：</div><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><div>dictionary ASMRequest {</div><div>    required Request requestType;  </div><div>    Version            asmVersion;   </div><div>    unsigned short   authenticatorIndex;  </div><div>     object              args; </div><div>     Extension[]      exts;//一般为空</div><div>};</div><div>其中 args 现在是：</div><div>dictionary RegisterIn {</div><div>    required DOMString      appID;</div><div>    required DOMString      username;</div><div>    required DOMString      finalChallenge;</div><div>    required unsigned short attestationType;</div><div>};</div></blockquote><div><br/></div><div style="font-size: 23px;"><font color="#939600">5.ASM收到消息之后,作如下操作:</font></div><div><span style="color: rgb(147, 150, 0); font-size: 23px;">   </span> 1.找到对应的认证器，如果没有对应的认证器，则返回操作错误的状态码</div><div>     2.如果用户已经注册过认证器了，那么则要让认证器验证用户的身份,如果验证失败，则返回拒绝的状态码</div><div>     3.如果用户并未注册过认证器，则要求用户进行对认证器的注册,如果注册失败，则返回失败的状态码</div><div>     4.生成KeyAccessToken的数值</div><div>     5.计算FinalChanllege的摘要数值（hash算法应该用认证器自己的hash算法）</div><div>     6.生成向认证器请求的数据格式,如下：</div><div style="font-size: 23px;"><font color="#939600"><span style="font-size: 20px;">  </span></font><img src="注册过程_files/2.png" type="image/png" height="599" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;" width="1126"/></div><div style="font-size: 23px;">  <img src="注册过程_files/3.png" type="image/png" height="265" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;" width="1296"/></div><div>     ASM向认证器发送如下信息体</div><div>     Object{</div><div>               TAG_AUTHENTICATOR_INDEX//注册过程中为一个特定的数值</div><div>               TAG_APPID</div><div>               TAG_FINAL_CHALLENGE// </div><div>               TAG_USERNAME</div><div>               TAG_ATTESTATION_TYPE//认证器的类型</div><div>               TAG_KEYHANDLE_ACCESS_TOKEN</div><div>               TAG_USERVERIFY_TOKEN (optional) //可选字段   </div><div>     }</div><div>         </div><div>  <span style="font-size: 23px;"><font color="#939600"> 6.认证器收到ASM的消息</font></span></div><div><span style="font-size: 23px;"><font color="#939600">   </font><span style="font-size: 17px;">做如下操作：</span></span></div><div>    <img src="注册过程_files/4.png" type="image/png" height="490" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;" width="1277"/></div><div> <img src="注册过程_files/5.png" type="image/png" height="470" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;" width="1301"/></div><div>大致翻译以上过程：</div><div>   1.KeyAceessToken再次进行更新</div><div>   2.用户通过指纹，虹膜，PIN或者其他近似的信息进行注册，并且验证令牌是否有效果(如果认证器支持的这个字段)（注：在此之前，认证器已经验证了用户的合法性）</div><div>  3.如果用户没有注册成功：   </div><div>    a.用户注册失败，返回响应代码： UAF_CMD_STATUS_ACCESS_DENIED<br/>
    b.用户放弃注册：返回响应代码：  UAF_CMD_STATUS_USER_CANCELLED</div><div>  4.确保<span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">TAG_ATTESTATION_TYPE</span><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;"> 是认证器支持的类型，否则返回不支持的响应的代码</span></div><div>  5.以上操作都没有问题之后，产生一个密钥对(公私钥)</div><div>  6.生成RawKeyHandle:</div><div>    a.将私钥加入RawKeyHandle对象</div><div>    b.将TAG_KEYHANDLE_ACCESS_TOKEN 加入RawKeyHandle对象</div><div>    c.如果是第一类认证器，则还要绑定用户名字</div><div> 7.对RawKeyHandle进行加密(加密方式由认证器决定）</div><div> 8.形成KRD的内容：（以TLV的形式）</div><div>    KRD[AAID,ASSERTION_INFO,FINAL_CHALLENGE(fcparams的SHA摘要信息),KEY_ID,COUNTERS,PUBLIC KEY,TAG_AUTHENTICATOR_NONCE( random)],</div><div>   9.按照协议规范组织KRD的内容</div><div>   10.生成签名证书（<span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">TAG_AUTHENTICATOR_ASSERTION</span>）的内容：</div><div>      a.用SHA对KRD的内容进行加密，用私钥生成签名</div><div>      b.加入X509的证书信息</div><div>      c如果是第一类认证器，则会把keyHandle发给ASM保存</div><div>   11.将KRD和<span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">TAG_AUTHENTICATOR_ASSERTION按照TLV的形式返回给ASM</span></div><div><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">  <span style="font-size: 23px;"><font color="#939600">7.认证器返回给ASM的信息：</font></span></span></div><div><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;"><span style="color: rgb(147, 150, 0); font-size: 23px;">    </span> 认证器返回给ASM的信息体如下：</span></div><div><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">        a.形成证书中的信息：</span></div><div><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">    AssertionObject｛</span></div><div>          TAG_AAID//认证器的类型</div><div>          TAG_ASSERTION_INFO//和每次操作的类型有关</div><div>          TAG_FINAL_CHALLENGE// 对finalChanllegeParams的摘要信息</div><div>          TAG_KEYID//KeyId(用来寻找KeyHandle)</div><div>          TAG_COUNTERS// 签名的次数的计数器</div><div>          TAG_PUB_KEY// 认证产生的公钥</div><div>          TAG_ATTESTATION_CERT//认证器内部的Fido 联盟的X509证书，交给FidoServer认证</div><div>          TAG_SIGNATURE// 对KRD信息的签名[用认证器的私钥进行加密]                 </div><div><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">    }</span></div><div><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;"> </span></div><div><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">     b. 形成返回给ASM 的信息体</span></div><div><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">       Object{</span></div><div><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">         </span>TAG_STATUS_CODE//认证器返回给ASM的状态字段</div><div><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">         </span><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">RegisterObject args//</span></div><div><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">         TAG_KEYHANDLE// </span></div><div><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">       }</span></div><div><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">  <span style="font-size: 23px;"><font color="#939600">8.ASM 收到 的信息后，做如下操作:</font></span></span></div><div><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">      1.如果是绑定类型的认证器，则会将认证器的返回的KeyId提取出来，然后将CallerID，AppID，  KeyId,KeyHandle 存储在ASM的自己的数据库内部.</span></div><div><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">      2.如果是非绑定类型的认证器，则认证器自己存储KeyHandle，ASM不做操作。</span></div><div><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">      3.ASM形成如下的数据，返回给Fido Client</span><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;"> </span></div><div><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">       </span>dictionary RegisterOut {</div>
    required DOMString assertion;//认证器返回给ASM的信息[<span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">RegisterObject]的内容</span><br/>
    required DOMString assertionScheme;// 'UAF1VTLV'<br/>
};
<div>  <span style="font-size: 23px;"><font color="#939600"> 9.FidoClient 收到ASM的返回的信息,做如下操作</font></span><br/><div>      形成返回给服务器的对象</div><div>       RegisterOut{</div><div>               Obejct Header//upv,op,appId,severData</div><div>               FinalChanllege fcParams</div><div>               RegisterOut  args//ASM 返回给fidoClient的信息<br/>
        } </div><div>    截图如下：<br/><div><img src="注册过程_files/6.png" type="image/png" height="419" style="cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;cursor: default;" width="1202"/></div><div> </div><div>  <span style="font-size: 23px;"><font color="#939600"> 10.fido服务器验证信息的有效性，如果有效，则返回给客户端注册成功的信息。</font></span></div><div><span style="background-color: rgb(255, 255, 255); font-family: sans-serif; text-align: left; widows: 1;"> </span></div><div style="text-align: left; widows: 1;"><font color="#8600A4"><br/></font></div><div style="text-align: left; widows: 1;"><font color="#8600A4">  </font></div></div></div></div>
</div></body></html> 