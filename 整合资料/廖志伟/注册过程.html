<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/272632; Windows/6.1.7600;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="670"/>

<div>
<div style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div>用户注册过程：</div><div style="font-size: 23px;"><font color="#939600">1.用户发送信息 facetID和userName</font></div><div>  facetID :android apk 的hash 摘要</div><div>  userName:用户名字</div><div><span style="font-size: 23px;"><font color="#939600">2.sever接收信息，然后发送UAFregRequest信息：</font></span> </div><div><img src="注册过程_files/1.png" type="image/png" height="268" style="cursor: default;cursor: default;cursor: default;cursor: default;" width="1177"/></div><div><br/></div><div>服务器的信息包含：header,upv,severData,op,policy,AppId </div><div><br/></div><div style="font-size: 23px;"><font color="#939600">3.服务器的信息传递给了fido客户端：fidoClient主要做一下两点处理：</font></div><div style="font-size: 23px;"><font color="#2D4FC9">fidoClient对 appId 进行处理：</font></div><div><font color="#FF0000">1.If the AppID is not an HTTPS URL, and matches the FacetID of the caller, no additional processing is necessary and the operation may proceed.</font></div><div>（如果AppID不是安全链接以及满足facetID的要求，就不做额外的处理）<br/><font color="#FF0000">2.If the AppID is null or empty, the client must set the AppID to be the FacetID of the caller, and the operation may proceed without additional processing.</font></div><div>(如果AppID是空的，那么FidoClient 必须用facetId 代替Appid)<br/><font color="#FF0000">3.If the caller's FacetID is an https:// Origin sharing the same host as the AppID, (e.g. if an application hosted at https://fido.example.com/myApp set an AppID of https://fido.example.com/myAppId), no additional processing is necessary and the operation may proceed. This algorithm may be continued asynchronously for purposes of caching the Trusted Facet List, if desired</font>.</div><div>（如果FaceID 含有https的标志，没有额外的处理是必要的，操作可以继续进行。如果想要的话，该算法可以在不需要的情况下继续以缓存的方式继续进行缓存。）</div><div><br/></div><div style="font-size: 20px;"><font color="#3665EE">fidoClient对 形成  <span style="line-height: 15.6px; widows: 1;"><a href="file:///#widl-RegisterIn-finalChallenge" style="border-bottom-width: 1px; border-bottom-style: dotted; border-bottom-color: rgb(255, 69, 0); text-decoration: none;">finalChallenge</a></span><span style="line-height: 15.6px; widows: 1;">;</span></font></div><div style="widows: 1;"><span style="line-height: 15px;">finalChallgne 就是appID 和challenge,facetIdf的json字符串的信息</span></div><div style="widows: 1;"><font color="#3665EE"><span style="line-height: 15px;"><br/></span></font></div><div style="widows: 1; font-size: 23px;"><font color="#939600">4.fido Client把信息了传递给ASM。</font></div><div style="font-size: 20px;"><font color="#3665EE">ASM regRequest接口信息如下:</font></div><div>dictionary ASMRequest {<br/>
    required Request requestType;  <br/>
    Version            asmVersion;   <br/>
    unsigned short   authenticatorIndex;  <br/>
     object              args; <br/>
     Extension[]      exts;<br/>
};</div><div>其中 args 现在是：</div><div>dictionary RegisterIn {<br/>
    required DOMString      appID;<br/>
    required DOMString      username;<br/>
    required DOMString      finalChallenge;<br/>
    required unsigned short attestationType;<br/>
};</div><div>requesetType  代表：GetInfo,Register,Authenticate,Deregister,GetRegistrations,OpenSettings，</div><div>现在在注册的过程中是Register</div><div><br/></div><div style="font-size: 23px;"><font color="#939600">5.ASM 向认证器发送消息</font></div><div style="font-size: 23px;"><font color="#939600"> </font> <span style="font-size: 20px;"><font color="#3665EE">1.ASM向认证器发送的信息（TLV格式）</font></span></div><div style="font-size: 23px;"><font color="#939600"><span style="font-size: 20px;">  </span></font><img src="注册过程_files/2.png" type="image/png" height="599" style="cursor: default;cursor: default;cursor: default;" width="1126"/></div><div style="font-size: 23px;">  <img src="注册过程_files/3.png" type="image/png" height="265" style="cursor: default;cursor: default;cursor: default;" width="1296"/></div><div>   TAG_UAF_SIGN_COMMND{</div><div>      TAG_AUTHENTICATOR_INDEX(注册的操作码：001)</div><div>       TAG_APPID</div><div>       AppID  </div><div>       TAG_FINAL_CHALLENGE   //finalChallenge;</div><div>       TAG_USERNAME    //userName</div><div>       TAG_ATTESTATION_TYPE  <a>//支持的认证器的类型</a> AAID</div><div>       TAG_KEYHANDLE_ACCESS_TOKEN // KHAccessToken<font color="#E30000">:【<span style="background-color: rgb(255, 255, 255); font-family: sans-serif; widows: 1;">A secret value that acts as a guard for authenticator commands. KHAccessTokens are generated and provided by an ASM.</span>】【一个秘密的数字，作为ASM打开认证器的依据】</font></div><div>        TAG_USERVERIFY_TOKEN //令牌</div><div>    }</div><div>         </div><div>  <span style="font-size: 23px;"><font color="#939600"> 6.认证器收到消息</font></span></div><div><span style="font-size: 23px;"><font color="#939600">   </font><span style="font-size: 17px;">做一下操作：</span></span></div><div>    <img src="注册过程_files/4.png" type="image/png" height="490" style="cursor: default;cursor: default;cursor: default;" width="1277"/></div><div> <img src="注册过程_files/5.png" type="image/png" height="470" style="cursor: default;cursor: default;cursor: default;" width="1301"/></div><div>大致翻译以上过程：</div><div>   1.</div><div>   2.用户通过指纹，虹膜，PIN或者其他近似的信息进行注册，并且验证令牌是否有效果</div><div>  3.如果User没有注册成功：   </div><div>    a.用户注册失败，返回响应代码： UAF_CMD_STATUS_ACCESS_DENIED<br/>
    b.用户放弃注册：返回响应代码：  UAF_CMD_STATUS_USER_CANCELLED</div><div>4.确保<span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">TAG_ATTESTATION_TYPE</span><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;"> 是认证器支持的类型，否则返回响应代码：</span>UAF_CMD_STATUS_ATTESTATION_NOT_SUPPORTED</div><div>5.以上操作都没有问题之后，产生一个密钥对(公私钥)</div><div>6.生成RawKeyHandle:</div><div>    a.将私钥加入RawKeyHandle对象</div><div>    b.将TAG_KEYHANDLE_ACCESS_TOKEN 加入RawKeyHandle对象</div><div> 7.对RawKeyHandle进行封装（加密,加密方式由认证器决定）</div><div> 8.形成KRD的内容：（以TLV的形式）</div><div>    KRD[AAID,ASSERTION_INFO,FINAL_CHALLENGE(fcparams的SHA摘要信息),KEY_ID,COUNTERS,PUBLIC KEY,TAG_AUTHENTICATOR_NONCE( random)],</div><div>   9.按照协议规范组织KRD的内容</div><div>   10.生成签名证书（<span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">TAG_AUTHENTICATOR_ASSERTION</span>）的内容：</div><div>      a.用SHA对KRD的内容进行加密，用私钥生成签名</div><div>      b.加入X509的证书信息</div><div>      c如果是第一类认证器，则会把keyHandle 发给服务器保存</div><div>   11.将KRD和<span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">TAG_AUTHENTICATOR_ASSERTION按照TLV的形式返回给ASM</span></div><div><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;"><br/></span></div><div><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">  <span style="font-size: 23px;"><font color="#939600">7.返回给服务器的json信息：</font></span></span></div><div><span style="background-color: rgb(255, 255, 255); text-align: left; widows: 1;">      </span><img src="注册过程_files/6.png" type="image/png" height="419" style="cursor: default;cursor: default;cursor: default;" width="1202"/></div><div> </div><div>  <span style="font-size: 23px;"><font color="#939600"> 8.fido服务器验证信息的有效性，如果有效，则返回给客户端注册成功的信息。</font></span></div><div><span style="background-color: rgb(255, 255, 255); font-family: sans-serif; text-align: left; widows: 1;"> </span></div><div style="text-align: left; widows: 1;"><font color="#8600A4"><br/></font></div><div style="text-align: left; widows: 1;"><font color="#8600A4">  </font></div></div>
</div></body></html> 